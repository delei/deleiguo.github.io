<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DeleiGuo</title>
  <subtitle>Target、Focus、Patient</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.deleiguo.com/"/>
  <updated>2016-12-09T10:43:07.000Z</updated>
  <id>https://www.deleiguo.com/</id>
  
  <author>
    <name>DeleiGuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【置顶】博客内容说明</title>
    <link href="https://www.deleiguo.com/2999/10/10/hellow-word/"/>
    <id>https://www.deleiguo.com/2999/10/10/hellow-word/</id>
    <published>2999-10-09T16:00:00.000Z</published>
    <updated>2016-12-09T10:43:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hello World!</p>
<pre><code>  ____           _          _    ____                 
 |  _  \   ___  | |   ___  (_)  / ___|  _   _    ___  
 | | | |  / _ \ | |  / _ \ | | | |  _  | | | |  / _ \
 | |_| | |  __/ | | |  __/ | | | |_| | | |_| | | (_) |
 |____/   \___| |_|  \___| |_|  \____|  \__,_|  \___/
</code></pre><a id="more"></a>
<blockquote>
<p>前段时间好不容易将备案的事情弄好了，搞得“身心疲惫”，这个过程挺烦琐的！<br>目前已将blog从 WordPress 迁到了 Hexo，deploy 到了github上</p>
</blockquote>
<p>早年的硬盘损坏让我至今后悔莫及，很多以前的资料再也没找回来。后来用印象笔记也用得不是很好，笔记杂乱，而且现在去看，发现资料内容都太老了，很多都不是最新的无法继续使用。一时间也不知道如何处理，甚至想一键删除。<br>这个博客小站如何建设一直在思考，有点无从下手的感觉。</p>
<p>有时工作一忙，又忘记了，效率有点慢！仅此来监督下自己，后续回归！</p>
<p>其实知识内容在网上有总结的很好的，在我重新审视建设本站的过程中，会根据我以前的资料来整理:</p>
<p>如果网上有好的内容，部分整理后拿过来，在文章中附上原文链接;<br>如果网上的内容较为分散，我会结合我自己的一些实际体会来整理成文;<br>如果自认为我自己整理不好，就直接附上地址不再复制粘贴;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hello World!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ____           _          _    ____                 
 |  _  \   ___  | |   ___  (_)  / ___|  _   _    ___  
 | | | |  / _ \ | |  / _ \ | | | |  _  | | | |  / _ \
 | |_| | |  __/ | | |  __/ | | | |_| | | |_| | | (_) |
 |____/   \___| |_|  \___| |_|  \____|  \__,_|  \___/
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="PRI-文章" scheme="https://www.deleiguo.com/categories/pri/"/>
    
    
      <category term="DeleiGuo" scheme="https://www.deleiguo.com/tags/DeleiGuo/"/>
    
  </entry>
  
  <entry>
    <title>Mac/Linux Tree命令</title>
    <link href="https://www.deleiguo.com/2017/02/09/linux-tree/"/>
    <id>https://www.deleiguo.com/2017/02/09/linux-tree/</id>
    <published>2017-02-08T16:00:00.000Z</published>
    <updated>2017-02-09T05:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h1><p>在Linux系统中有tree命令，tree命令以树状图列出文件目录结构。<br>执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件。</p>
<a id="more"></a>
<h2 id="tree命令行参数（只适用于安装了tree命令行工具）："><a href="#tree命令行参数（只适用于安装了tree命令行工具）：" class="headerlink" title="tree命令行参数（只适用于安装了tree命令行工具）："></a>tree命令行参数（只适用于安装了tree命令行工具）：</h2><p>实例：</p>
<pre><code class="lang-bash">[deleiguo@test config]$ tree
.
|-- context.xml
|-- server.xml
`-- v1.0
    |-- conf.properties
    `-- log4j.properties

1 directory, 4 files
</code></pre>
<p>以下为主要的参数译文：</p>
<pre><code class="lang-bash">-a 显示所有文件和目录。
-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。
-C 在文件和目录清单加上色彩，便于区分各种类型。
-d 显示目录名称而非内容。
-D 列出文件或目录的更改时间。
-f 在每个文件或目录之前，显示完整的相对路径名称。
-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上&quot;*&quot;,&quot;/&quot;,&quot;=&quot;,&quot;@&quot;,&quot;|&quot;号。
-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。
-i 不以阶梯状列出文件或目录名称。
-I 不显示符合范本样式的文件或目录名称。
-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。
-n 不在文件和目录清单加上色彩。
-N 直接列出文件和目录名称，包括控制字符。
-p 列出权限标示。
-P 只显示符合范本样式的文件或目录名称。
-q 用&quot;?&quot;号取代控制字符，列出文件和目录名称。
-s 列出文件或目录大小。
-t 用文件和目录的更改时间排序。
-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。
-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。
</code></pre>
<blockquote>
<p>Linux中可以用<code>man tree</code>来查看更加详细的帮助说明</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>不是所有的linux系统中都有tree命令，例如CentOS，其次类Unix系统Mac中也没有</p>
<h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p>CentOS默认也没有tree命令，可以使用如下命令安装后使用</p>
<pre><code class="lang-bash">sudo yum install tree
</code></pre>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>mac中并没有tree,有几种方法实现tree</p>
<h5 id="模拟Tree命令"><a href="#模拟Tree命令" class="headerlink" title="模拟Tree命令"></a>模拟Tree命令</h5><blockquote>
<p>这其实是用find来模拟的。无法实现linux tree命令的所有功能和参数</p>
</blockquote>
<p>在用户目录中，在<code>.bash_profeile</code>中添加</p>
<pre><code class="lang-bash">alias tree=&quot;find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39;&quot;
</code></pre>
<p>然后<code>source .bash_profile</code>即可生效</p>
<h5 id="安装Tree命令-推荐"><a href="#安装Tree命令-推荐" class="headerlink" title="安装Tree命令(推荐)"></a>安装Tree命令(推荐)</h5><p>现在mac上安装<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a>:</p>
<pre><code class="lang-bash">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>然后</p>
<pre><code class="lang-bash">sudo brew install tree
</code></pre>
<h2 id="引用内容文章"><a href="#引用内容文章" class="headerlink" title="引用内容文章"></a>引用内容文章</h2><ul>
<li><a href="http://www.runoob.com/linux/linux-comm-tree.html" target="_blank" rel="external">菜鸟教程-Linux tree命令</a></li>
<li>博客园：破男孩<a href="http://www.cnblogs.com/ayseeing/p/4097066.html" target="_blank" rel="external">mac tree命令</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;tree&quot;&gt;&lt;a href=&quot;#tree&quot; class=&quot;headerlink&quot; title=&quot;tree&quot;&gt;&lt;/a&gt;tree&lt;/h1&gt;&lt;p&gt;在Linux系统中有tree命令，tree命令以树状图列出文件目录结构。&lt;br&gt;执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件。&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="Mac" scheme="https://www.deleiguo.com/tags/Mac/"/>
    
      <category term="Linux" scheme="https://www.deleiguo.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>简单的SAAS软件开发与设计</title>
    <link href="https://www.deleiguo.com/2017/02/09/easy-saas/"/>
    <id>https://www.deleiguo.com/2017/02/09/easy-saas/</id>
    <published>2017-02-08T16:00:00.000Z</published>
    <updated>2017-02-09T07:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端时间结合公司业务，主导的试推出了业务系统SAAS版本，没有采用大型的架构，只是结合业务要求，又有成本和项目进度考虑而已。</p>
<blockquote>
<p>到目前为止，算是蹒跚起步，没有SAAS经验给的小白，也没有人告诉我们团队应该怎么做,应该做成什么样子，没有技术指导<br><br>在经过简单的技术实验后，也算是有个V0.1了，开始在阿里云部署并进行内部VIP客户内测，技术上肯定还是有很多没有想好和想到的地方，先记录一下，让以后的自己回头看和总结比较</p>
</blockquote>
<h2 id="1-服务架构"><a href="#1-服务架构" class="headerlink" title="1. 服务架构"></a>1. 服务架构</h2><h3 id="1-1-硬件环境"><a href="#1-1-硬件环境" class="headerlink" title="1.1 硬件环境"></a>1.1 硬件环境</h3><p><img src="/2017/02/09/easy-saas/001.png" alt=""></p>
<a id="more"></a>
<blockquote>
<p>主要为SAAS，分布式负载均衡方案</p>
</blockquote>
<ul>
<li>负载均衡方式（两个以上的web容器提供应用服务）；</li>
<li>负载均衡为外网，负责转发流量负载；</li>
<li>应用服务器，数据库，缓存服务，备份服务，文件服务等位于内网，不暴露至公网；</li>
<li>每一个节点基本为一台单一的服务器，有独立的内/外网IP进行服务；</li>
</ul>
<blockquote>
<p>单机配置环境<br>负载均衡:nginx<br>应用服务器：不同端口同一IP地址<br>数据库：mysql<br>缓存服务：redis<br>文件服务：本地盘符硬盘位置</p>
</blockquote>
<h3 id="1-2-SAAS"><a href="#1-2-SAAS" class="headerlink" title="1.2 SAAS"></a>1.2 SAAS</h3><h4 id="什么是SAAS"><a href="#什么是SAAS" class="headerlink" title="什么是SAAS"></a>什么是SAAS</h4><blockquote>
<p><a href="http://baike.baidu.com/link?url=6ZlndxwkbLPOgAJmdr_m8P9Epo78IcSFPzQ-GBE8IOxpRZUR_L_o1VlKrq_U3PKPJd0WhHU_BQJ7-P0H0dlgfK" target="_blank" rel="external">百度百科-saas</a><br><a href="http://baike.baidu.com/link?url=2REx4ks4t-ierKw4ViBLnLqQc5fWgL0jlCSpPtG-pgU6GJYHq09MQMEQiRbSfrqCaABFS0z7Ejoj0Ph9sQE2WnNFak5PEpZaGNxR2kudfMG" target="_blank" rel="external">百度百科-saas模式</a></p>
</blockquote>
<p>SaaS是Software-as-a-service（软件即服务）,主要特性：</p>
<ul>
<li><p>互联网<br>一方面，SaaS服务通过互联网浏览器或WebServices/Web2.0程序连接的形式为用户提供服务，使得SaaS应用具备了典型互联网技术特点;另一方面，由于SaaS极大的缩短了用户与SaaS提供商之间的时空距离，从而使得SaaS服务的营销、交付与传统软件相比有着很大的不同。</p>
</li>
<li><p>多租户<br>SaaS服务通常基于一套标准软件系统为成百上千的不同客户(又称租户)提供服务。这要求SaaS服务要能够支持不同租户之间数据和配置的隔离，从而保证每个租户数据的安全与隐私，以及用户对诸如界面、业务逻辑、数据结构等的个性化需求。由于SaaS同时支持多个租户，每个租户又有很多用户，这对支撑软件的基础设施平台的性能、稳定性、扩展性提出很大挑战。</p>
</li>
<li><p>服务特性<br>SaaS使得软件以互联网为载体的服务形式被客户使用，所以服务合约的签定、服务使用的计量、在线服务质量的保证、服务费用的收取等等问题都必须考虑。而这些问题通常是传统软件没有考虑到的。<br>SaaS(Software asaService，软件即服务)是通过互联网以服务形式交付和使用软件的业务模式。在SaaS模式下，软件使用者无需购置额外硬件设备、软件许可证及安装和维护软件系统，通过互联网浏览器在任何时间、任何地点都可以轻松使用软件并按照使用量定期支付使用费。</p>
</li>
<li><p>模型分级：<br>  根据SaaS应用是否具有可配置性，高性能，可伸缩性的特性，SaaS成熟度模型被分成四级。每一级都比前一级增加三种特性中的一种。</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>等级</th>
<th>可配置</th>
<th>高性能</th>
<th>可伸缩</th>
</tr>
</thead>
<tbody>
<tr>
<td>Level1</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Level2</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Level3</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>Level4</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>定制开发<br>这种模型下，软件服务提供商为每个客户定制一套软件，并为其部署。每个客户使用一个独立的数据库实例和应用服务器实例。数据库中的数据结构和应用的代码可能都根据客户需求做过定制化修改。（多次开发）</p>
</li>
<li><p>可配置<br>通过不同的配置满足不同客户的需求，而不需要为每个客户进行特定定制，以降低定制开发的成本。<br>但是，软件的部署架构没有太大的变化，依然为每个客户独立部署一个运行实例。只是每个运行实例运行的是同一份代码，通过配置的不同来满足不同客户的个性化需求。<br>可配置性的比较通用的实现方式，就是通过MetaData（元数据）来实现。（一次开发多次部署）</p>
</li>
<li><p>多租架构<br>多租户单实例（Multi-Tenant）的应用架构才是通常真正意义上的SaaS应用架构，它可以有效降低SaaS应用的硬件及运行维护成本，最大化地发挥SaaS应用的规模效应。（一次开发一次部署）</p>
</li>
<li><p>可伸缩架构<br>将第三级的Multi-Tenant SingleInstance系统扩展为Multi-Tenant MultiInstance。最终用户首先通过接入Tenant Load Balance层，再被分配到不同的Instance上。通过多个Instance来分担大量用户的访问，我们可以让应用实现近似无限的水平扩展。<br>要实现第四级成熟度模型，最复杂的就是针对原有单个Instance的数据库服务器，实现其数据的水平拆分。</p>
</li>
</ul>
<h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><blockquote>
<p><a href="http://blog.csdn.net/chenhuajie123/article/details/9264015" target="_blank" rel="external">SaaS系统中的数据模型设计思路</a><br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-dataMultitenant/index.html" target="_blank" rel="external">数据层的多租户浅谈</a></p>
</blockquote>
<p>数据层的三种多租户架构:</p>
<ol>
<li>独立数据库</li>
<li>共享数据库、独立 Schema</li>
<li>共享数据库、共享 Schema、共享数据表</li>
</ol>
<p>独立数据库是一个租户独享一个数据库实例，它提供了最强的分离度，租户的数据彼此物理不可见，备份与恢复都很灵活；共享数据库、独立 Schema 将每个租户关联到同一个数据库的不同 Schema，租户间数据彼此逻辑不可见，上层应用程序的实现和独立数据库一样简单，但备份恢复稍显复杂； 最后一种模式则是租户数据在数据表级别实现共享，它提供了最低的成本，但引入了额外的编程复杂性（程序的数据访问需要用 tenantId 来区分不同租户），备份与恢复也更复杂。这三种模式的特点可以用一张图来概括：<br><img src="/2017/02/09/easy-saas/004.jpg" alt=""></p>
<p>我们的数据库设计：</p>
<p><img src="/2017/02/09/easy-saas/002.png" alt=""></p>
<ul>
<li>每一个公司(租户)是一个单独的mysql database；</li>
<li>每一个公司(租户)通过唯一的公司代码用于登录</li>
<li>每一个公司(租户)都有各自的用户表，可以有该公司的admin用户来独立管理系统</li>
</ul>
<p>其他：</p>
<ul>
<li>有一个单独的数据库实例(company)来管理公司(租户)信息，以及公司(租户)的数据源datasource信息；</li>
<li>用户在登录时访问的是company datasource,然后将(租户)的数据源信息放入当前session中；</li>
<li>当公司(租户)数量增加时，可通过增加mysql实例来实现无缝水平扩展(程序无需配置或重启)；</li>
</ul>
<h3 id="1-3-应用设计"><a href="#1-3-应用设计" class="headerlink" title="1.3 应用设计"></a>1.3 应用设计</h3><h4 id="缓存改造"><a href="#缓存改造" class="headerlink" title="缓存改造"></a>缓存改造</h4><p>不同的应用服务器部署的是同一份代码，所有的应用连接的都是同一份数据库。Tomcat集群可通过tomcat本身支持的session持久化相关保证session同步（目前采用的是redis方案）。<br>除此外，程序考虑和改造如下部分：</p>
<ol>
<li><p>程序缓存改造:<br> 缓存一般都在本机内存中，或者是持久化在本地盘。在分布式环境下， 需要考虑缓存同步，采用的是redis作为缓存存储，所有的应用服务从redis中获取和更新缓存。<br> 在代码中使用Spring cache注解，实际配置为redis来存储:applicationContext.xml</p>
<pre><code class="lang-xml"> &lt;!-- spring自己的换管理器，这里定义了两个缓存位置名称 ，既注解中的value --&gt;
 &lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.data.redis.cache.RedisCacheManager&quot;&gt;
     &lt;constructor-arg ref=&quot;redisTemplate&quot; /&gt;
 &lt;/bean&gt;

 &lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
     &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt;
     &lt;property name=&quot;minIdle&quot; value=&quot;${redis.minIdle}&quot; /&gt;
 &lt;/bean&gt;

 &lt;bean id=&quot;connectionFactory&quot;
     class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;
     &lt;property name=&quot;hostName&quot; value=&quot;${redis.host}&quot; /&gt;
     &lt;property name=&quot;port&quot; value=&quot;${redis.port}&quot; /&gt;
     &lt;property name=&quot;password&quot; value=&quot;${redis.password}&quot; /&gt;
     &lt;property name=&quot;database&quot; value=&quot;${redis.database}&quot; /&gt;
     &lt;property name=&quot;timeout&quot; value=&quot;${redis.timeout}&quot; /&gt;
     &lt;property name=&quot;usePool&quot; value=&quot;true&quot; /&gt;
     &lt;property name=&quot;poolConfig&quot; ref=&quot;poolConfig&quot; /&gt;
 &lt;/bean&gt;

 &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;
     &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;
     &lt;property name=&quot;keySerializer&quot;&gt;
         &lt;bean
             class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot; /&gt;
     &lt;/property&gt;
     &lt;property name=&quot;valueSerializer&quot;&gt;
         &lt;bean
             class=&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot; /&gt;
     &lt;/property&gt;
 &lt;/bean&gt;
</code></pre>
</li>
<li><p>Shiro<br> shiro本身也可以使用缓存，比如ehcache，但为了统一，所以都换成使用redis来处理：applicationContext-shiro.xml</p>
<pre><code class="lang-xml"> &lt;!-- 缓存管理器 使用redis实现 --&gt;
 &lt;bean id=&quot;redisManager&quot; class=&quot;com.datadriver.web.common.redis.RedisManager&quot;&gt;
     &lt;property name=&quot;hostName&quot; value=&quot;${redis.host}&quot; /&gt;
     &lt;property name=&quot;port&quot; value=&quot;${redis.port}&quot; /&gt;
     &lt;property name=&quot;password&quot; value=&quot;${redis.password}&quot; /&gt;
     &lt;property name=&quot;database&quot; value=&quot;${redis.shiro.database}&quot; /&gt;
     &lt;property name=&quot;poolConfig&quot; ref=&quot;poolConfig&quot; /&gt;
 &lt;/bean&gt;
 &lt;!-- cacheManager --&gt;
 &lt;bean id=&quot;shiroCacheManager&quot; class=&quot;com.datadriver.web.common.redis.RedisCacheManager&quot;&gt;
     &lt;property name=&quot;redisManager&quot; ref=&quot;redisManager&quot; /&gt;
 &lt;/bean&gt;

 &lt;!-- 会话DAO --&gt;
 &lt;bean id=&quot;redisSessionDAO&quot; class=&quot;com.datadriver.web.common.redis.RedisSessionDAO&quot;&gt;
     &lt;property name=&quot;redisManager&quot; ref=&quot;redisManager&quot; /&gt;
 &lt;/bean&gt;

 &lt;!-- 会话管理器 --&gt;
 &lt;bean id=&quot;sessionManager&quot;
     class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt;
     &lt;property name=&quot;sessionDAO&quot; ref=&quot;redisSessionDAO&quot; /&gt;
 &lt;/bean&gt;

 &lt;!-- 安全管理器 --&gt;
 &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;
     &lt;property name=&quot;realms&quot;&gt;
         &lt;list&gt;
             &lt;ref bean=&quot;securityRealm&quot; /&gt;
         &lt;/list&gt;
     &lt;/property&gt;
     &lt;!-- cacheManager,集合spring缓存工厂 --&gt;
     &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroCacheManager&quot; /&gt;
     &lt;!-- &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot; /&gt; --&gt;
 &lt;/bean&gt;
</code></pre>
</li>
</ol>
<h4 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h4><p>在spring中，多数据源主要通过路由AbstractRoutingDataSource类来实现，我们可以继承这个类，来实现多数据源的情况。<br>详细代码：<code>com.datadriver.web.common.dbcontext.AbstractRoutingDataSource</code></p>
<p>使用这个类，可以实现常见的几种业务场景：</p>
<ol>
<li>读写分离：读数据是一个db,写数据是两外一个sb；直接在xml中配置多个数据源即可；</li>
<li>业务库分离：每一个db代表着一种业务（例如用户库，商品库，权限库等），这样需要在程序xml预先配置好这些数据源，然后在程序中不同业务中指定相应的数据源</li>
<li>。。。</li>
</ol>
<p>根据业务需要，我们在此基础上再次进行了改造：</p>
<pre><code class="lang-java">    private Map&lt;Object, Object&gt;    _targetDataSources;

        private final static String    DEFAULT_DATASOURCE_KEY        = &quot;dataSource&quot;;
        /**
         * 只能在本类中特定使用
         */
        private final static String    DEFAULT_DATASOURCE_NEW        = &quot;NEW&quot;;
        /**
         * 供给特殊应用场景使用
         */
        public final static String    DEFAULT_DATASOURCE_COMPANY    = &quot;COMPANY&quot;;

        /**
         * @see org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource#determineCurrentLookupKey()
         * @describe 数据源为空或者为0时，自动切换至默认数据源，即在配置文件中定义的dataSource数据源
         */
        @Override
        protected Object determineCurrentLookupKey() {
            String dataSourceName = DBContextHolder.getDBType();
            try {
                if (!StringUtils.isBlank(dataSourceName) &amp;&amp; DEFAULT_DATASOURCE_COMPANY.equals(dataSourceName)) {
                    // company操作
                    dataSourceName = DEFAULT_DATASOURCE_KEY;
                } else if (!StringUtils.isBlank(dataSourceName) &amp;&amp; DEFAULT_DATASOURCE_NEW.equals(dataSourceName)) {
                    // new则默认datasource
                    dataSourceName = DEFAULT_DATASOURCE_KEY;
                } else {
                    // 从Session中获取datasource key
                    ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
                    // 查看session是否存在
                    if (requestAttributes != null) {
                        HttpServletRequest request = requestAttributes.getRequest();
                        if (request != null) {
                            String sessionDataSourceName = (String) WebUtils.getSessionAttribute(request, SessionAttribute.DBCONTEXT);
                            // 如果是NEW表明是特殊逻辑获取新的datasource
                            if (!StringUtils.isBlank(sessionDataSourceName)) {
                                dataSourceName = sessionDataSourceName;
                            } else {
                                dataSourceName = DEFAULT_DATASOURCE_KEY;
                            }
                        }
                    }
                }
            } catch (Exception e) {
                UnitedLogger.error(&quot;--------&gt; DynamicDataSource error: &quot; + e);
            }
            if (StringUtils.isBlank(dataSourceName)) {
                dataSourceName = DEFAULT_DATASOURCE_KEY;
            }
            this.selectDataSource(dataSourceName);
            UnitedLogger.error(&quot;--------&gt; use datasource &quot; + dataSourceName);
            return dataSourceName;
        }
</code></pre>
<p>这其中主要是<code>determineCurrentLookupKey</code>方法,实现了如下场景：</p>
<ol>
<li>不同的公司(租户)使用不同的datasource;</li>
<li>程序xml中不需要预先设定好数据源，只需要设定好company库的数据源；</li>
<li>如果当前公司(租户)是新公司(租户)，那么用户在登录时如果不存在datasource，则会通过company库查询数据库源，放入<code>_targetDataSources</code>中；</li>
<li>每一个公司(租户)的用户在登录时，会将公司(租户)信息放入session中，每一次调用dao都会通过<code>determineCurrentLookupKey</code>方法，该方法根据session中的公司(租户)信息判断该用户使用的是<code>_targetDataSources</code>的哪一个数据源;</li>
</ol>
<p>其他：</p>
<ul>
<li>使用的是来自阿里的开源Druid数据库连接工具，开启了Druid的监控页面可以看到多个数据源的监控情况；</li>
</ul>
<p><img src="/2017/02/09/easy-saas/005.png" alt=""></p>
<ul>
<li>在程序中不需要在某一个service方法钱手动指定数据源；</li>
<li>开发者无需关注多数据源情况，只需要按照单数据源来进行开发测试即可；</li>
<li>该应用可以支持单机单数据源部署；</li>
</ul>
<h2 id="2-服务器设置"><a href="#2-服务器设置" class="headerlink" title="2. 服务器设置"></a>2. 服务器设置</h2><h3 id="2-1-系统相关"><a href="#2-1-系统相关" class="headerlink" title="2.1 系统相关"></a>2.1 系统相关</h3><ul>
<li><p>系统</p>
<pre><code class="lang-bash">  LSB Version:    :core-4.1-amd64:core-4.1-noarch
  Distributor ID:    CentOS
  Description:    CentOS Linux release 7.3.1611 (Core)
  Release:    7.3.1611
  Codename:    Core
</code></pre>
</li>
<li><p>软件源<br>  使用的国内aliyun的yum源<a href="http://mirrors.aliyun.com/help/centos" target="_blank" rel="external">Ali-OSM</a></p>
<blockquote>
<p>使用阿里云服务器，将源的域名从mirrors.aliyun.com改为mirrors.aliyuncs.com,不占用公网流量</p>
</blockquote>
<pre><code class="lang-bash">  已加载插件：fastestmirror
  Loading mirror speeds from cached hostfile
   * base: mirrors.aliyuncs.com
   * epel: mirrors.aliyuncs.com
   * extras: mirrors.aliyuncs.com
   * updates: mirrors.aliyuncs.com
  源标识                            源名称                                                      状态
  !base/7/x86_64                   CentOS-7 - Base - mirrors.aliyun.com                       9,363
  !epel/x86_64                     Extra Packages for Enterprise Linux 7 - x86_64             10,976
  !extras/7/x86_64                 CentOS-7 - Extras - mirrors.aliyun.com                     435
  !updates/7/x86_64                CentOS-7 - Updates - mirrors.aliyun.com                    433
  repolist: 21,207
</code></pre>
</li>
</ul>
<h3 id="2-2-Tomcat相关"><a href="#2-2-Tomcat相关" class="headerlink" title="2.2 Tomcat相关"></a>2.2 Tomcat相关</h3><ul>
<li><p>版本</p>
<blockquote>
<p>apache-tomcat-7.0.73</p>
</blockquote>
</li>
<li><p>参数:<code>bin/catalina.sh</code></p>
<pre><code class="lang-bash">  # datadriver folder
  DATADRIVER_APP_FOLDER=/home/datadriver/app/
  # 内存设置
  JAVA_OPTS=&quot;$JAVA_OPTS  -server -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=512m -XX:PermSize=512m -XX:MaxPermSize=512m&quot;
  # 日志相关，使用CMS
  JAVA_OPTS=&quot;$JAVA_OPTS -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly &quot;
  JAVA_OPTS=&quot;$JAVA_OPTS -XX:MaxTenuringThreshold=6 -XX:+ExplicitGCInvokesConcurrent -XX:+ParallelRefProcEnabled&quot;
  # 日志目录，打印GC Details
  JAVA_OPTS=&quot;$JAVA_OPTS -Xloggc:${DATADRIVER_APP_FOLDER}logs/app_gc_%Y-%m-%d.log -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps -XX:+PrintGCDetails&quot;
  # 当jvm出现异常时，日志目录和dump文件目录
  JAVA_OPTS=&quot;$JAVA_OPTS -XX:-OmitStackTraceInFastThrow -XX:ErrorFile=${DATADRIVER_APP_FOLDER}logs/jvm_err_%p_%Y-%m-%d.log -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${DATADRIVER_APP_FOLDER}heapdump/&quot;
</code></pre>
<blockquote>
<p>因为设置较长，分开多行来设置</p>
</blockquote>
</li>
<li><p>设置<code>conf</code></p>
<ul>
<li><p>server.xml</p>
<ul>
<li><p>开启ThreadPool</p>
<pre><code class="lang-bash">&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot;
maxThreads=&quot;300&quot; minSpareThreads=&quot;10&quot;/&gt;
</code></pre>
</li>
<li><p>编码:UTF-8</p>
<pre><code class="lang-bash">&lt;Connector executor=&quot;tomcatThreadPool&quot;
     port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
     connectionTimeout=&quot;20000&quot;
     redirectPort=&quot;8443&quot; URIEcoding=&quot;UTF-8&quot; /&gt;
</code></pre>
</li>
<li><p>开启GZIP</p>
<pre><code class="lang-bash">&lt;Connector executor=&quot;tomcatThreadPool&quot;
     port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
     connectionTimeout=&quot;20000&quot;
     redirectPort=&quot;8443&quot; URIEcoding=&quot;UTF-8&quot;
     compression=&quot;on&quot;
     compressionMinSize=&quot;2048&quot;
     noCompressionUserAgents=&quot;gozilla,traviata&quot;
     compressableMimeType=&quot;text/html,text/xml,text/javascript,application/x-javascript,application/javascript,text/css,text/plain&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Tomcat7集群/分布式部署(使用Redis)</p>
<blockquote>
<p><a href="https://github.com/jcoleman/tomcat-redis-session-manager" target="_blank" rel="external">jcoleman</a>:tomcat-redis-session-manage-tomcat7<br><a href="http://blog.csdn.net/caiwenfeng_for_23/article/details/45666831" target="_blank" rel="external">Tomcat7+Redis存储Session</a></p>
</blockquote>
<ul>
<li><p>单点Redis配置</p>
<pre><code class="lang-bash">&lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt;
&lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;
  host=&quot;r-bp1f2aa502d15a94.redis.rds.aliyuncs.com&quot;
  port=&quot;6379&quot;
  database=&quot;0&quot;
  password=&quot;Appadmin68868569&quot;/&gt;
</code></pre>
</li>
<li><p>以下的jar文件放入Tomcat <code>lib</code>目录下</p>
<pre><code class="lang-bash">commons-logging-1.1.3.jar
commons-pool2-2.2.jar
jedis-2.5.2.jar
tomcat-juli.jar
tomcat-redis-session-manage-tomcat7.jar
</code></pre>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端时间结合公司业务，主导的试推出了业务系统SAAS版本，没有采用大型的架构，只是结合业务要求，又有成本和项目进度考虑而已。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;到目前为止，算是蹒跚起步，没有SAAS经验给的小白，也没有人告诉我们团队应该怎么做,应该做成什么样子，没有技术指导&lt;br&gt;&lt;br&gt;在经过简单的技术实验后，也算是有个V0.1了，开始在阿里云部署并进行内部VIP客户内测，技术上肯定还是有很多没有想好和想到的地方，先记录一下，让以后的自己回头看和总结比较&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-服务架构&quot;&gt;&lt;a href=&quot;#1-服务架构&quot; class=&quot;headerlink&quot; title=&quot;1. 服务架构&quot;&gt;&lt;/a&gt;1. 服务架构&lt;/h2&gt;&lt;h3 id=&quot;1-1-硬件环境&quot;&gt;&lt;a href=&quot;#1-1-硬件环境&quot; class=&quot;headerlink&quot; title=&quot;1.1 硬件环境&quot;&gt;&lt;/a&gt;1.1 硬件环境&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2017/02/09/easy-saas/001.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="Java" scheme="https://www.deleiguo.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【转】阿里巴巴集团Java代码规范</title>
    <link href="https://www.deleiguo.com/2017/02/09/alibaba-java-develop-norm/"/>
    <id>https://www.deleiguo.com/2017/02/09/alibaba-java-develop-norm/</id>
    <published>2017-02-08T16:00:00.000Z</published>
    <updated>2017-02-09T05:43:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，没有规定靠右行驶，谁还敢上路。同理，对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的方式一起做事。阿里巴巴集团推出的Java开发手册是阿里巴巴近万名开发同学集体智慧的结晶，以开发视角为中心，详细列举如何开发更加高效，更加容错，更加有协作性，力求知其然，更知其不然，结合正反例，让Java开发者能够提升协作效率、提高代码质量。手册内容划分为编程规约、异常日志规约、MYSQL规约、工程规约、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱，规约依次分为强制、推荐、参考三大类:</p>
<p>【强制】必须遵守。是不得不遵守的约定，违反本约定或将会引起严重的后果。<br>【推荐】尽量遵守。长期遵守这样的规定，有助于系统稳定性和合作效率的提升。<br>【参考】充分理解。技术意识的引导，是个人学习、团队沟通、项目合作的方向。<br><a id="more"></a></p>
<p><img src="/2017/02/09/alibaba-java-develop-norm/alibaba-java-develop-norm.jpg" alt="阿里巴巴Java开发手册"></p>
<p><a href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C.pdf" target="_blank" rel="external">点击下载开发手册(PDF)</a></p>
<h2 id="在线预览"><a href="#在线预览" class="headerlink" title="在线预览"></a>在线预览</h2>

	<div class="row">
    <embed src="./alibaba-java-develop-norm.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h2 id="引用内容文章"><a href="#引用内容文章" class="headerlink" title="引用内容文章"></a>引用内容文章</h2><ul>
<li><a href="https://102.alibaba.com/newsInfo.htm?newsId=6" target="_blank" rel="external">阿里巴巴集团Java代码规范</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，没有规定靠右行驶，谁还敢上路。同理，对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的方式一起做事。阿里巴巴集团推出的Java开发手册是阿里巴巴近万名开发同学集体智慧的结晶，以开发视角为中心，详细列举如何开发更加高效，更加容错，更加有协作性，力求知其然，更知其不然，结合正反例，让Java开发者能够提升协作效率、提高代码质量。手册内容划分为编程规约、异常日志规约、MYSQL规约、工程规约、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱，规约依次分为强制、推荐、参考三大类:&lt;/p&gt;
&lt;p&gt;【强制】必须遵守。是不得不遵守的约定，违反本约定或将会引起严重的后果。&lt;br&gt;【推荐】尽量遵守。长期遵守这样的规定，有助于系统稳定性和合作效率的提升。&lt;br&gt;【参考】充分理解。技术意识的引导，是个人学习、团队沟通、项目合作的方向。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="Java" scheme="https://www.deleiguo.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM GC个人小抄</title>
    <link href="https://www.deleiguo.com/2016/12/26/jvm-gc-xiaochao/"/>
    <id>https://www.deleiguo.com/2016/12/26/jvm-gc-xiaochao/</id>
    <published>2016-12-25T16:00:00.000Z</published>
    <updated>2017-02-09T09:23:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新生代、老年代"><a href="#新生代、老年代" class="headerlink" title="新生代、老年代"></a>新生代、老年代</h1><ul>
<li>new 新的对象，当new 大的对象时，可以直接在老年代，大小可以通过参数 -XX:PretenureSizeThreshold 来设置</li>
<li>内存大小通过-Xmn -Xmx等设置</li>
<li>s区与Edem区的比例大小设置一般默认为1:8，可以通过-SuvivorRatio 来设置。但该参数在某一个些 GC 方式中无效，比如有些 GC 中是根据实际使用情况动态分配大小的。</li>
<li>在新生过经过多次回收后依然存在的对象则进老年代</li>
<li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快”</li>
<li>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上</li>
</ul>
<h4 id="永久代-JVM方法区"><a href="#永久代-JVM方法区" class="headerlink" title="永久代(JVM方法区)"></a>永久代(JVM方法区)</h4><p>各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据<br>JDK8</p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="判定回收"><a href="#判定回收" class="headerlink" title="判定回收"></a>判定回收</h2><p>GC ROOTs起始，向下找引用链，如果找不到任何引用，则对象不可用(类似树结构)</p>
<p>该类的所有实例对象都已经被回收<br>加载该类的ClassLoader已经被回收<br>该类对应的反射类java.lang.Class对象没有被任何地方引用</p>
<h2 id="GC-方式"><a href="#GC-方式" class="headerlink" title="GC 方式"></a>GC 方式</h2><p>在启动参数中增加-XX:+DisableExplicitGC来避免程序中调用 System.gc 触发 GC</p>
<p>新生代主要基于 Copying 算法(将存活的对象复制到一块未使用的空间，然后将剩余的空间清空)。Eden 中存放新创建的对象，S0或S1用来复制，当其中一块为复制的目标空间，另一块的内容则被清空。</p>
<p>主要有串行 GC、并行回收 GC 、并行 GC</p>
<ul>
<li><p>串行 GC(Serial GC)<br>采用单线程方式，也是 client 级别下默认采用的GC的方式，可以用过-XX:+UserSerialGC来强制指定</p>
</li>
<li><p>并行回收 GC(ParalleclGC)<br>  在启动时，Eden S0 S1的比例划分可以用过-XX：SurvivorRadio来调整，但在运行一段时间后，并行回收GC会根据 Minor GC 的频率、消耗时间等来动态调整Eden S0 S1的大小。也可通过-XX:UserAdaptiveSizePolicy来固定Eden S0 S1的大小</p>
<p>  在扫描和复制时采用多线程方式。适合多 CPU、对暂停时间要求较短的应用。也是 Sever 级别上默认采用的 GC 方式，也可以通过-XX:UserParalleclGC来强制指定。</p>
<p>  默认的线程数根据 CPU 的核数来计算:</p>
<ul>
<li>CPU 核数小于8时，并行的线程数即为CPU核数;</li>
<li>CPU 核数大于8时，并行的线程数即为3+(CPU核数*5)/8,也可以通过-XX:ParallelGCThreads=4来强制指定线程数；</li>
</ul>
</li>
<li><p>并行 GC(ParNew)<br>  需配合旧生代使用CMS GC,CMS GC在老年代 GC 时，有些是并发执行的，如此时发生Minor GC,需要进行相应的处理，而并行回收GC是没有这些处理。<br>  在配置 CMS GC 下，新生代默认采用并行 GC，也可通过-XX:UserParNewGC强制指定<br>  使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数</p>
</li>
<li><p>Parallel Scavenge<br>  CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%”<br>  控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数</p>
</li>
<li><p>Parallel Old<br>  Parallel Scavenge的老年代版，使用多线程和”标记-整理”算法。</p>
</li>
<li><p>CMS<br>  最短回收停顿时间，基于”标记-清除”算法，并发收集，收集结束会产生空间碎片，不连续空间。可能出现的情况：老年代有很大空间剩余，但是无法找到足够大的连续空间来分配，不得不提前触发一次Full GC.CMS GC 提供-XX:+UserCMSCompactAtFullCollection开发(默认开启)，开启内存碎片的合并整理过程，另外-XX:CMSFullGCsBeforeCompaction，用于设置执行多少次不亚索的 Full GC 后，紧接着进行压缩整理碎片<br>  对 CPU 资源很敏感，并发会占用一部分线程(或 CPU)而导致应用程序变慢，总吞吐量降低</p>
</li>
<li><p>G1<br>  面向服务端应用。并行与并发，可以不需要其他收集器配合就能独立管理整个 GC 堆。主要基于”标记-整理”算法。<br>  使用 G1，是将Java 堆划分为多个大小星等的独立区域(Region)，新生代和老年代不再物理隔离，它们都是一部分 Region集合</p>
</li>
</ul>
<h2 id="查看-GC"><a href="#查看-GC" class="headerlink" title="查看 GC"></a>查看 GC</h2><h4 id="输出-GC-日志"><a href="#输出-GC-日志" class="headerlink" title="输出 GC 日志"></a>输出 GC 日志</h4><ul>
<li><p>控制台<br>JVM 启动参数-XX:+PrintGC -XX:+PrincGCDetails </p>
</li>
<li><p>输出到文件<br>JVM启动参数加入-Xloggc:gc.log</p>
</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>强引用：new Ojbect,只要该引用存在，则永不会回收该类对象，需要在程序中主动处理</li>
<li>软引用：SofeReference，在 JVM 内存不足时才会被回收，可以用来实现缓存，当 GC 扫描到的该类对象不经常使用，也会进行回收。存活的时间可以同-XX:SofeRefLRUpolicyMSPerM来进行控制，默认为1秒</li>
<li>弱引用：WeakReference，这类对象只能存活到下一次回收(没有强引用)</li>
<li>虚引用：PhantomReference，</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;新生代、老年代&quot;&gt;&lt;a href=&quot;#新生代、老年代&quot; class=&quot;headerlink&quot; title=&quot;新生代、老年代&quot;&gt;&lt;/a&gt;新生代、老年代&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;new 新的对象，当new 大的对象时，可以直接在老年代，大小可以通过参数 -XX:Pr
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 命令</title>
    <link href="https://www.deleiguo.com/2016/12/10/java-comman/"/>
    <id>https://www.deleiguo.com/2016/12/10/java-comman/</id>
    <published>2016-12-10T03:12:15.000Z</published>
    <updated>2016-12-14T17:19:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>笔者环境：开启eclipse,使用的 JDK:Java HotSpot(TM) 64-Bit Server( “1.7.0_79”)<br>51933为 eclipse LVMID</p>
</blockquote>
<p>JDK 中bin目录中有很多命令行工具，这些事对jdk/lib/tools.jar类库的一层包装，主要的功能代码是在tools类库中实现。</p>
<blockquote>
<p>tools.jar包在oracle的jvm中会自带，但其他厂商的 jvm，如 IBM 的j9等不一定有，如果需要也可以在部署程序时一起部署这个jar</p>
</blockquote>
<a id="more"></a>
<h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><h2 id="q-只显示LVMID-省略主类的名称"><a href="#q-只显示LVMID-省略主类的名称" class="headerlink" title="-q :只显示LVMID,省略主类的名称"></a>-q :只显示LVMID,省略主类的名称</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jps -q
51933
52249
</code></pre>
<h2 id="m-输出虚拟机进程时传递给主类main-方法的参数"><a href="#m-输出虚拟机进程时传递给主类main-方法的参数" class="headerlink" title="-m :输出虚拟机进程时传递给主类main()方法的参数"></a>-m :输出虚拟机进程时传递给主类main()方法的参数</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jps -m
51933
52284 Jps -m
</code></pre>
<h2 id="l-输出主类的全名，如果执行的是jar包，输出-jar的路径"><a href="#l-输出主类的全名，如果执行的是jar包，输出-jar的路径" class="headerlink" title="-l :输出主类的全名，如果执行的是jar包，输出 jar的路径"></a>-l :输出主类的全名，如果执行的是jar包，输出 jar的路径</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jps -l
51933
52303 sun.tools.jps.Jps
</code></pre>
<h2 id="v-输出虚拟机进程启动时jvm参数"><a href="#v-输出虚拟机进程启动时jvm参数" class="headerlink" title="-v :输出虚拟机进程启动时jvm参数"></a>-v :输出虚拟机进程启动时jvm参数</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jps -v
51933  -Dosgi.requiredJavaVersion=1.7 -XstartOnFirstThread -Dorg.eclipse.swt.internal.carbon.smallFonts -XX:MaxPermSize=256m -Xms256m -Xmx1024m -Xdock:icon=../Resources/Eclipse.icns -XstartOnFirstThread -Dorg.eclipse.swt.internal.carbon.smallFonts
52315 Jps -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home -Xms8m
</code></pre>
<p>使用-v可以查看 jvm 参数设置是否已生效</p>
<h2 id="引用内容文章"><a href="#引用内容文章" class="headerlink" title="引用内容文章"></a>引用内容文章</h2><ul>
<li><a href="http://www.hollischuang.com/archives/105" target="_blank" rel="external">HollisChuang’s Blog:Java命令学习系列（一）——Jps</a></li>
<li><a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html" target="_blank" rel="external">jps - Java Virtual Machine Process Status Tool</a></li>
</ul>
<h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><p>该命令的jdk7开始，该命令在后续版本中可能不再使用，在jdk8中已不支持该命令</p>
<pre><code class="lang-bash">-flag &lt;name&gt;         to print the value of the named VM flag
-flag [+|-]&lt;name&gt;    to enable or disable the named VM flag
-flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value
-flags               to print VM flags
-sysprops            to print Java system properties
&lt;no option&gt;          to print both of the above
-h | -help           to print this help message
</code></pre>
<blockquote>
<p>在笔者的jdk环境中还是可以使用该命令的(机器暂时没装jdk8)</p>
</blockquote>
<pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jinfo -flags 51933
Attaching to process ID 51933, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 24.79-b02

-Dosgi.requiredJavaVersion=1.7 -XstartOnFirstThread -Dorg.eclipse.swt.internal.carbon.smallFonts -XX:MaxPermSize=256m -Xms256m -Xmx1024m -Xdock:icon=../Resources/Eclipse.icns -XstartOnFirstThread -Dorg.eclipse.swt.internal.carbon.smallFonts
</code></pre>
<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>是用于监控虚拟机各种运行状态信息的命令行工具。他可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</p>
<p>需要远程主机提供RMI支持，oracle jdk可以使用jstatd工具</p>
<h2 id="class-坚持类加载、卸载数量、总空间以及类装载所耗费的时间"><a href="#class-坚持类加载、卸载数量、总空间以及类装载所耗费的时间" class="headerlink" title="-class :坚持类加载、卸载数量、总空间以及类装载所耗费的时间"></a>-class :坚持类加载、卸载数量、总空间以及类装载所耗费的时间</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -class 51933
Loaded  Bytes  Unloaded  Bytes     Time
15591 34025.2        0     0.0      15.45
</code></pre>
<h2 id="gc-坚持-Java-堆状况，包括-Eden，survivor，老年代，永久带等的容量，已用空间、GC-时间合集等信息"><a href="#gc-坚持-Java-堆状况，包括-Eden，survivor，老年代，永久带等的容量，已用空间、GC-时间合集等信息" class="headerlink" title="-gc :坚持 Java 堆状况，包括 Eden，survivor，老年代，永久带等的容量，已用空间、GC 时间合集等信息"></a>-gc :坚持 Java 堆状况，包括 Eden，survivor，老年代，永久带等的容量，已用空间、GC 时间合集等信息</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -gc 51933
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT
58880.0 62976.0  0.0    0.0   193536.0 97183.2   382976.0   123877.1  153088.0 96650.8     32    0.445   6      2.812    3.257
</code></pre>
<ul>
<li>S0C 年轻代中第一个survivor（幸存区）的容量 (字节)</li>
<li>S1C 年轻代中第二个survivor（幸存区）的容量 (字节)</li>
<li>S0U 年轻代中第一个survivor（幸存区）目前已使用空间 (字节)</li>
<li>S1U 年轻代中第二个survivor（幸存区）目前已使用空间 (字节)</li>
<li>EC 年轻代中Eden（伊甸园）的容量 (字节)</li>
<li>EU 年轻代中Eden（伊甸园）目前已使用空间 (字节)</li>
<li>OC Old代的容量 (字节)</li>
<li>OU Old代目前已使用空间 (字节)</li>
<li>PC Perm(持久代)的容量 (字节)</li>
<li>PU Perm(持久代)目前已使用空间 (字节)</li>
<li>YGC 从应用程序启动到采样时年轻代中gc次数</li>
<li>YGCT 从应用程序启动到采样时年轻代中gc所用时间(s)</li>
<li>FGC 从应用程序启动到采样时old代(全gc)gc次数</li>
<li>FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s)</li>
<li>GCT 从应用程序启动到采样时gc用的总时间(s)</li>
</ul>
<h2 id="gccapacity-与gc基本相同，但主要关注Java堆各个区域使用到的最大、最小空间"><a href="#gccapacity-与gc基本相同，但主要关注Java堆各个区域使用到的最大、最小空间" class="headerlink" title="-gccapacity 与gc基本相同，但主要关注Java堆各个区域使用到的最大、最小空间"></a>-gccapacity 与gc基本相同，但主要关注Java堆各个区域使用到的最大、最小空间</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -gccapacity 51933
 NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC      PGCMN    PGCMX     PGC       PC     YGC    FGC
 87552.0 349696.0 319488.0 58880.0 62976.0 193536.0   175104.0   698880.0   382976.0   382976.0  21504.0 262144.0 153088.0 153088.0     32     6
</code></pre>
<ul>
<li>NGCMN 年轻代(young)中初始化(最小)的大小(字节)</li>
<li>NGCMX 年轻代(young)的最大容量 (字节)</li>
<li>NGC 年轻代(young)中当前的容量 (字节)</li>
<li>S0C 年轻代中第一个survivor（幸存区）的容量 (字节)</li>
<li>S1C 年轻代中第二个survivor（幸存区）的容量 (字节)</li>
<li>EC 年轻代中Eden（伊甸园）的容量 (字节)</li>
<li>OGCMN old代中初始化(最小)的大小 (字节)</li>
<li>OGCMX old代的最大容量(字节)</li>
<li>OGC old代当前新生成的容量 (字节)</li>
<li>OC Old代的容量 (字节)</li>
<li>PGCMN perm代中初始化(最小)的大小 (字节)</li>
<li>PGCMX perm代的最大容量 (字节)</li>
<li>PGC perm代当前新生成的容量 (字节)</li>
<li>PC Perm(持久代)的容量 (字节)</li>
<li>YGC 从应用程序启动到采样时年轻代中gc次数</li>
<li>FGC 从应用程序启动到采样时old代(全gc)gc次数</li>
</ul>
<h2 id="gcutil-与gc基本相同，但主要挂住已使用空间占总空间的百分比"><a href="#gcutil-与gc基本相同，但主要挂住已使用空间占总空间的百分比" class="headerlink" title="-gcutil 与gc基本相同，但主要挂住已使用空间占总空间的百分比"></a>-gcutil 与gc基本相同，但主要挂住已使用空间占总空间的百分比</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -gcutil 51933
  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT   
  0.00   0.00  71.76  32.35  63.17     32    0.445     6    2.812    3.257
</code></pre>
<ul>
<li>S0 年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</li>
<li>S1 年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</li>
<li>E 年轻代中Eden（伊甸园）已使用的占当前容量百分比</li>
<li>O old代已使用的占当前容量百分比</li>
<li>P perm代已使用的占当前容量百分比</li>
<li>YGC 从应用程序启动到采样时年轻代中gc次数</li>
<li>YGCT 从应用程序启动到采样时年轻代中gc所用时间(s)</li>
<li>FGC 从应用程序启动到采样时old代(全gc)gc次数</li>
<li>FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s)</li>
<li>GCT 从应用程序启动到采样时gc用的总时间(s)</li>
</ul>
<h2 id="gccause-与gcutil基本相同，但是会额外输出导致上一次-GC-产应的原因LGCC"><a href="#gccause-与gcutil基本相同，但是会额外输出导致上一次-GC-产应的原因LGCC" class="headerlink" title="-gccause 与gcutil基本相同，但是会额外输出导致上一次 GC 产应的原因LGCC"></a>-gccause 与gcutil基本相同，但是会额外输出导致上一次 GC 产应的原因LGCC</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -gccause 51933
  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 
  0.00   0.00  90.17  32.35  63.18     32    0.445     6    2.812    3.257 System.gc()          No GC
</code></pre>
<h2 id="gcnew-新生代gc-状况"><a href="#gcnew-新生代gc-状况" class="headerlink" title="-gcnew 新生代gc 状况"></a>-gcnew 新生代gc 状况</h2><pre><code class="lang-bash"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  
58880.0 62976.0    0.0    0.0  9  15 62976.0 193536.0 180917.7     32    0.445
</code></pre>
<ul>
<li>S0C 年轻代中第一个survivor（幸存区）的容量 (字节)</li>
<li>S1C 年轻代中第二个survivor（幸存区）的容量 (字节)</li>
<li>S0U 年轻代中第一个survivor（幸存区）目前已使用空间 (字节)</li>
<li>S1U 年轻代中第二个survivor（幸存区）目前已使用空间 (字节)</li>
<li>TT 持有次数限制 MTT 最大持有次数限制</li>
<li>EC 年轻代中Eden（伊甸园）的容量 (字节)</li>
<li>EU 年轻代中Eden（伊甸园）目前已使用空间 (字节)</li>
<li>YGC 从应用程序启动到采样时年轻代中gc次数</li>
<li>YGCT 从应用程序启动到采样时年轻代中gc所用时间(s)</li>
</ul>
<h2 id="gcnewcapacity-与gcnew基本相同，输出主要关注使用的最大、最小空间"><a href="#gcnewcapacity-与gcnew基本相同，输出主要关注使用的最大、最小空间" class="headerlink" title="-gcnewcapacity 与gcnew基本相同，输出主要关注使用的最大、最小空间"></a>-gcnewcapacity 与gcnew基本相同，输出主要关注使用的最大、最小空间</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -gcnewcapacity 51933
  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC
   87552.0   349696.0   319488.0 116224.0  58880.0 116224.0  62976.0   348672.0   193536.0    32     6
</code></pre>
<ul>
<li>NGCMN 年轻代(young)中初始化(最小)的大小(字节)</li>
<li>NGCMX 年轻代(young)的最大容量 (字节)</li>
<li>NGC 年轻代(young)中当前的容量 (字节)</li>
<li>S0CMX 年轻代中第一个survivor（幸存区）的最大容量 (字节)</li>
<li>S0C 年轻代中第一个survivor（幸存区）的容量 (字节)</li>
<li>S1CMX 年轻代中第二个survivor（幸存区）的最大容量 (字节)</li>
<li>S1C 年轻代中第二个survivor（幸存区）的容量 (字节)</li>
<li>ECMX 年轻代中Eden（伊甸园）的最大容量 (字节)</li>
<li>EC 年轻代中Eden（伊甸园）的容量 (字节)</li>
<li>YGC 从应用程序启动到采样时年轻代中gc次数</li>
<li>FGC 从应用程序启动到采样时old代(全gc)gc次数</li>
</ul>
<h2 id="gcold-老年代GC状况"><a href="#gcold-老年代GC状况" class="headerlink" title="-gcold 老年代GC状况"></a>-gcold 老年代GC状况</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -gcold 51933
   PC       PU        OC          OU       YGC    FGC    FGCT     GCT   
153088.0  96730.3    382976.0    123877.1     32     6    2.812    3.257
</code></pre>
<ul>
<li>PC Perm(持久代)的容量 (字节)</li>
<li>PU Perm(持久代)目前已使用空间 (字节)</li>
<li>OC Old代的容量 (字节)</li>
<li>OU Old代目前已使用空间 (字节)</li>
<li>YGC 从应用程序启动到采样时年轻代中gc次数</li>
<li>FGC 从应用程序启动到采样时old代(全gc)gc次数</li>
<li>FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s)</li>
<li>GCT 从应用程序启动到采样时gc用的总时间(s)</li>
</ul>
<h2 id="gcoldcapacity-与gcold基本相同，主要关注使用到的最大、最小空间"><a href="#gcoldcapacity-与gcold基本相同，主要关注使用到的最大、最小空间" class="headerlink" title="-gcoldcapacity 与gcold基本相同，主要关注使用到的最大、最小空间"></a>-gcoldcapacity 与gcold基本相同，主要关注使用到的最大、最小空间</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -gcoldcapacity 51933
   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT   
   175104.0    698880.0    382976.0    382976.0    33     6    2.812    3.317
</code></pre>
<ul>
<li>OGCMN old代中初始化(最小)的大小 (字节)</li>
<li>OGCMX old代的最大容量(字节)</li>
<li>OGC old代当前新生成的容量 (字节)</li>
<li>OC Old代的容量 (字节)</li>
<li>YGC 从应用程序启动到采样时年轻代中gc次数</li>
<li>FGC 从应用程序启动到采样时old代(全gc)gc次数</li>
<li>FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s)</li>
<li>GCT 从应用程序启动到采样时gc用的总时间(s)</li>
</ul>
<h2 id="gcpermcapacity-永久代使用的最大、最小空间"><a href="#gcpermcapacity-永久代使用的最大、最小空间" class="headerlink" title="-gcpermcapacity 永久代使用的最大、最小空间"></a>-gcpermcapacity 永久代使用的最大、最小空间</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -gcpermcapacity 51933
  PGCMN      PGCMX       PGC         PC      YGC   FGC    FGCT     GCT   
   21504.0   262144.0   153088.0   153088.0    33     6    2.812    3.317
</code></pre>
<ul>
<li>PGCMN perm代中初始化(最小)的大小 (字节)</li>
<li>PGCMX perm代的最大容量 (字节)<br>PGC perm代当前新生成的容量 (字节)<br>PC Perm(持久代)的容量 (字节)<br>YGC 从应用程序启动到采样时年轻代中gc次数<br>FGC 从应用程序启动到采样时old代(全gc)gc次数<br>FGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s)<br>GCT 从应用程序启动到采样时gc用的总时间(s)</li>
</ul>
<h2 id="compiler-JIT-编译器编译过的方法、耗时信息"><a href="#compiler-JIT-编译器编译过的方法、耗时信息" class="headerlink" title="-compiler JIT 编译器编译过的方法、耗时信息"></a>-compiler JIT 编译器编译过的方法、耗时信息</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -compiler 51933
Compiled Failed Invalid   Time   FailedType FailedMethod
    2867      0       0    27.54          0
</code></pre>
<ul>
<li>Compiled 编译任务执行数量</li>
<li>Failed 编译任务执行失败数量</li>
<li>Invalid 编译任务执行失效数量</li>
<li>Time 编译任务消耗时间</li>
<li>FailedType 最后一个编译失败任务的类型</li>
<li>FailedMethod 最后一个编译失败任务所在的类及方法</li>
</ul>
<h2 id="printcompilation-输出已被JIT编译的方法"><a href="#printcompilation-输出已被JIT编译的方法" class="headerlink" title="-printcompilation 输出已被JIT编译的方法"></a>-printcompilation 输出已被JIT编译的方法</h2><pre><code class="lang-bash">delei@DeleitekiMacBook-Pro:~$ jstat -printcompilation 51933
Compiled  Size  Type Method
    2867    439    1 org/eclipse/emf/common/util/CommonUtil$StringPool$SelfCleaningStringPoolEntry clear
</code></pre>
<ul>
<li>Compiled 编译任务的数目</li>
<li>Size 方法生成的字节码的大小</li>
<li>Type 编译类型</li>
<li>Method 类名和方法名用来标识编译的方法。类名使用/做为一个命名空间分隔符。方法名是给定类中的方法。上述格式是由-XX:+PrintComplation选项进行设置的</li>
</ul>
<h2 id="引用内容文章-1"><a href="#引用内容文章-1" class="headerlink" title="引用内容文章"></a>引用内容文章</h2><ul>
<li>blog：<a href="http://www.hollischuang.com/archives/481" target="_blank" rel="external">HollisChuang’s Blog » Java命令学习系列（四）——jstat</a></li>
<li>书籍：<a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机（第2版）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔者环境：开启eclipse,使用的 JDK:Java HotSpot(TM) 64-Bit Server( “1.7.0_79”)&lt;br&gt;51933为 eclipse LVMID&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JDK 中bin目录中有很多命令行工具，这些事对jdk/lib/tools.jar类库的一层包装，主要的功能代码是在tools类库中实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tools.jar包在oracle的jvm中会自带，但其他厂商的 jvm，如 IBM 的j9等不一定有，如果需要也可以在部署程序时一起部署这个jar&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="Java" scheme="https://www.deleiguo.com/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>高效团队-HRT 原则</title>
    <link href="https://www.deleiguo.com/2016/11/24/efficient-team-HRT/"/>
    <id>https://www.deleiguo.com/2016/11/24/efficient-team-HRT/</id>
    <published>2016-11-24T04:47:54.000Z</published>
    <updated>2016-12-08T09:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>摘至: <a href="http://www.ituring.com.cn/book/1759" target="_blank" rel="external">进化:从孤胆极客到高效团队</a></p>
</blockquote>
<p>要达到团队合作的最高境界，首先需要学习和掌握被称为“三大基石”的社交技能。这三大原则不仅可以调和人际关系，还是所有良好交互与合作的基础</p>
<h2 id="谦虚-Humility"><a href="#谦虚-Humility" class="headerlink" title="谦虚(Humility)"></a>谦虚(Humility)</h2><p>你并非宇宙中心，并非无所不知，也会犯错，但愿自我改进。</p>
<h2 id="尊重-Respect"><a href="#尊重-Respect" class="headerlink" title="尊重(Respect)"></a>尊重(Respect)</h2><p>你要真诚关心同时，以礼相待，欣赏其能力，认可其成就。</p>
<h2 id="信任-Trust"><a href="#信任-Trust" class="headerlink" title="信任(Trust)"></a>信任(Trust)</h2><p>你要相信别人可以胜任工作并作出正确选择，愿意在核实的时候将权利交给他们(如果你曾经放权给不称职的人并对此经历无法释怀，据极难做到这一点)。</p>
<p>我们将这些原则合称为HRT，HRT原则是为了减轻痛苦，而非伤害他人.<br>我们的主要论点直接建立在这三大基石之上：</p>
<pre><code>几乎每种社交冲突的源头最终都可归结于谦虚、尊重或信任的缺失
</code></pre><p>这一论点初听起来可能缺乏说服力，但你不妨试一试。想想生活中正在发生的一些令人讨厌或不快的社交问题，在最基础的层面上，每个人是否足够谦虚？人们是否真的彼此尊重？他们相互信任吗？</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘至: &lt;a href=&quot;http://www.ituring.com.cn/book/1759&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进化:从孤胆极客到高效团队&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要达到团
    
    </summary>
    
      <category term="PRI-文章" scheme="https://www.deleiguo.com/categories/pri/"/>
    
    
      <category term="Team" scheme="https://www.deleiguo.com/tags/Team/"/>
    
  </entry>
  
  <entry>
    <title>JVM实用参数（八）GC日志</title>
    <link href="https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-8-gc-logging/"/>
    <id>https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-8-gc-logging/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2016-12-08T10:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自并发编程网 – ifeve.com本文链接地址: <a href="http://ifeve.com/useful-jvm-flags-part-8-gc-logging/" target="_blank" rel="external">JVM实用参数（八）GC日志</a><br>本文是<a href="http://ifeve.com" target="_blank" rel="external">并发编程网</a>经原国外blog作者授权的中文译文</p>
</blockquote>
<p><strong>译者:</strong> Greenster<br><strong>校对:</strong> 梁海舰<br>本系列的最后一部分是有关垃圾收集（GC）日志的JVM参数。GC日志是一个很重要的工具，它准确记录了每一次的GC的执行时间和执行结果，通过分析GC日志可以优化堆设置和GC设置，或者改进应用程序的对象分配模式。</p>
<h2 id="XX-PrintGC"><a href="#XX-PrintGC" class="headerlink" title="-XX:+PrintGC"></a>-XX:+PrintGC</h2><p>参数-XX:+PrintGC（或者-verbose:gc）开启了简单GC日志模式，为每一次新生代（young generation）的GC和每一次的Full GC打印一行信息。下面举例说明：</p>
<pre><code class="lang-bash">[GC 246656K-&gt;243120K(376320K), 0.0929090 secs]
[Full GC 243120K-&gt;241951K(629760K), 1.5589690 secs]
</code></pre>
<p>每行开始首先是GC的类型（可以是“GC”或者“Full GC”），然后是在GC之前和GC之后已使用的堆空间，再然后是当前的堆容量，最后是GC持续的时间（以秒计）。</p>
<a id="more"></a>
<p>第一行的意思就是GC将已使用的堆空间从246656K减少到243120K，当前的堆容量（译者注：GC发生时）是376320K，GC持续的时间是0.0929090秒。</p>
<p>简单模式的GC日志格式是与GC算法无关的，日志也没有提供太多的信息。在上面的例子中，我们甚至无法从日志中判断是否GC将一些对象从young generation移到了old generation。所以详细模式的GC日志更有用一些。</p>
<h2 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:PrintGCDetails"></a>-XX:PrintGCDetails</h2><p>如果不是使用-XX:+PrintGC，而是-XX:PrintGCDetails，就开启了详细GC日志模式。在这种模式下，日志格式和所使用的GC算法有关。我们首先看一下使用Throughput垃圾收集器在young generation中生成的日志。为了便于阅读这里将一行日志分为多行并使用缩进。</p>
<pre><code class="lang-bash">[GC
    [PSYoungGen: 142816K-&gt;10752K(142848K)] 246648K-&gt;243136K(375296K), 0.0935090 secs
]
[Times: user=0.55 sys=0.10, real=0.09 secs]
</code></pre>
<p>我们可以很容易发现：这是一次在young generation中的GC，它将已使用的堆空间从246648K减少到了243136K，用时0.0935090秒。此外我们还可以得到更多的信息：所使用的垃圾收集器（即PSYoungGen）、young generation的大小和使用情况（在这个例子中“PSYoungGen”垃圾收集器将young generation所使用的堆空间从142816K减少到10752K）。</p>
<p>既然我们已经知道了young generation的大小，所以很容易判定发生了GC，因为young generation无法分配更多的对象空间：已经使用了142848K中的142816K。我们可以进一步得出结论，多数从young generation移除的对象仍然在堆空间中，只是被移到了old generation：通过对比绿色的和蓝色的部分可以发现即使young generation几乎被完全清空（从142816K减少到10752K），但是所占用的堆空间仍然基本相同（从246648K到243136K）。</p>
<p>详细日志的“Times”部分包含了GC所使用的CPU时间信息，分别为操作系统的用户空间和系统空间所使用的时间。同时，它显示了GC运行的“真实”时间（0.09秒是0.0929090秒的近似值）。如果CPU时间（译者注：0.55秒+0.10秒）明显多于”真实“时间（译者注：0.09秒），我们可以得出结论：GC使用了多线程运行。这样的话CPU时间就是所有GC线程所花费的CPU时间的总和。实际上我们的例子中的垃圾收集器使用了8个线程。</p>
<p>接下来看一下Full GC的输出日志</p>
<pre><code class="lang-bash">[Full GC
    [PSYoungGen: 10752K-&gt;9707K(142848K)]
    [ParOldGen: 232384K-&gt;232244K(485888K)] 243136K-&gt;241951K(628736K)
    [PSPermGen: 3162K-&gt;3161K(21504K)], 1.5265450 secs
]
</code></pre>
<p>除了关于young generation的详细信息，日志也提供了old generation和permanent generation的详细信息。对于这三个generations，一样也可以看到所使用的垃圾收集器、堆空间的大小、GC前后的堆使用情况。需要注意的是显示堆空间的大小等于young generation和old generation各自堆空间的和。以上面为例，堆空间总共占用了241951K，其中9707K在young generation，232244K在old generation。Full GC持续了大约1.53秒，用户空间的CPU执行时间为10.96秒，说明GC使用了多线程（和之前一样8个线程）。</p>
<p>对不同generation详细的日志可以让我们分析GC的原因，如果某个generation的日志显示在GC之前，堆空间几乎被占满，那么很有可能就是这个generation触发了GC。但是在上面的例子中，三个generation中的任何一个都不是这样的，在这种情况下是什么原因触发了GC呢。对于Throughput垃圾收集器，在某一个generation被过度使用之前，GC ergonomics（参考本系列第6节）决定要启动GC。</p>
<p>Full GC也可以通过显式的请求而触发，可以是通过应用程序，或者是一个外部的JVM接口。这样触发的GC可以很容易在日志里分辨出来，因为输出的日志是以“Full GC(System)”开头的，而不是“Full GC”。</p>
<p>对于Serial垃圾收集器，详细的GC日志和Throughput垃圾收集器是非常相似的。唯一的区别是不同的generation日志可能使用了不同的GC算法（例如：old generation的日志可能以Tenured开头，而不是ParOldGen）。使用垃圾收集器作为一行日志的开头可以方便我们从日志就判断出JVM的GC设置。</p>
<p>对于CMS垃圾收集器，young generation的详细日志也和Throughput垃圾收集器非常相似，但是old generation的日志却不是这样。对于CMS垃圾收集器，在old generation中的GC是在不同的时间片内与应用程序同时运行的。GC日志自然也和Full GC的日志不同。而且在不同时间片的日志夹杂着在此期间young generation的GC日志。但是了解了上面介绍的GC日志的基本元素，也不难理解在不同时间片内的日志。只是在解释GC运行时间时要特别注意，由于大多数时间片内的GC都是和应用程序同时运行的，所以和那种独占式的GC相比，GC的持续时间更长一些并不说明一定有问题。</p>
<p>正如我们在第7节中所了解的，即使CMS垃圾收集器没有完成一个CMS周期，Full GC也可能会发生。如果发生了GC，在日志中会包含触发Full GC的原因，例如众所周知的”concurrent mode failure“。</p>
<p>为了避免过于冗长，我这里就不详细说明CMS垃圾收集器的日志了。另外，CMS垃圾收集器的作者做了详细的说明（在这里），强烈建议阅读。</p>
<h2 id="XX-PrintGCTimeStamps和-XX-PrintGCDateStamps"><a href="#XX-PrintGCTimeStamps和-XX-PrintGCDateStamps" class="headerlink" title="-XX:+PrintGCTimeStamps和-XX:+PrintGCDateStamps"></a>-XX:+PrintGCTimeStamps和-XX:+PrintGCDateStamps</h2><p>使用-XX:+PrintGCTimeStamps可以将时间和日期也加到GC日志中。表示自JVM启动至今的时间戳会被添加到每一行中。例子如下：</p>
<pre><code class="lang-bash">0.185: [GC 66048K-&gt;53077K(251392K), 0.0977580 secs]
0.323: [GC 119125K-&gt;114661K(317440K), 0.1448850 secs]
0.603: [GC 246757K-&gt;243133K(375296K), 0.2860800 secs]
</code></pre>
<p>如果指定了-XX:+PrintGCDateStamps，每一行就添加上了绝对的日期和时间。</p>
<pre><code class="lang-bash">2014-01-03T12:08:38.102-0100: [GC 66048K-&gt;53077K(251392K), 0.0959470 secs]
2014-01-03T12:08:38.239-0100: [GC 119125K-&gt;114661K(317440K), 0.1421720 secs]
2014-01-03T12:08:38.513-0100: [GC 246757K-&gt;243133K(375296K), 0.2761000 secs]
</code></pre>
<p>如果需要也可以同时使用两个参数。推荐同时使用这两个参数，因为这样在关联不同来源的GC日志时很有帮助。</p>
<h2 id="Xloggc"><a href="#Xloggc" class="headerlink" title="-Xloggc"></a>-Xloggc</h2><p>缺省的GC日志时输出到终端的，使用-Xloggc:也可以输出到指定的文件。需要注意这个参数隐式的设置了参数-XX:+PrintGC和-XX:+PrintGCTimeStamps，但为了以防在新版本的JVM中有任何变化，我仍建议显示的设置这些参数。</p>
<h2 id="可管理的JVM参数"><a href="#可管理的JVM参数" class="headerlink" title="可管理的JVM参数"></a>可管理的JVM参数</h2><p>一个常常被讨论的问题是在生产环境中GC日志是否应该开启。因为它所产生的开销通常都非常有限，因此我的答案是需要开启。但并不一定在启动JVM时就必须指定GC日志参数。</p>
<p>HotSpot JVM有一类特别的参数叫做可管理的参数。对于这些参数，可以在运行时修改他们的值。我们这里所讨论的所有参数以及以“PrintGC”开头的参数都是可管理的参数。这样在任何时候我们都可以开启或是关闭GC日志。比如我们可以使用JDK自带的jinfo工具来设置这些参数，或者是通过JMX客户端调用HotSpotDiagnostic MXBean的setVMOption方法来设置这些参数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自并发编程网 – ifeve.com本文链接地址: &lt;a href=&quot;http://ifeve.com/useful-jvm-flags-part-8-gc-logging/&quot;&gt;JVM实用参数（八）GC日志&lt;/a&gt;&lt;br&gt;本文是&lt;a href=&quot;http://ifeve.com&quot;&gt;并发编程网&lt;/a&gt;经原国外blog作者授权的中文译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;译者:&lt;/strong&gt; Greenster&lt;br&gt;&lt;strong&gt;校对:&lt;/strong&gt; 梁海舰&lt;br&gt;本系列的最后一部分是有关垃圾收集（GC）日志的JVM参数。GC日志是一个很重要的工具，它准确记录了每一次的GC的执行时间和执行结果，通过分析GC日志可以优化堆设置和GC设置，或者改进应用程序的对象分配模式。&lt;/p&gt;
&lt;h2 id=&quot;XX-PrintGC&quot;&gt;&lt;a href=&quot;#XX-PrintGC&quot; class=&quot;headerlink&quot; title=&quot;-XX:+PrintGC&quot;&gt;&lt;/a&gt;-XX:+PrintGC&lt;/h2&gt;&lt;p&gt;参数-XX:+PrintGC（或者-verbose:gc）开启了简单GC日志模式，为每一次新生代（young generation）的GC和每一次的Full GC打印一行信息。下面举例说明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;[GC 246656K-&amp;gt;243120K(376320K), 0.0929090 secs]
[Full GC 243120K-&amp;gt;241951K(629760K), 1.5589690 secs]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每行开始首先是GC的类型（可以是“GC”或者“Full GC”），然后是在GC之前和GC之后已使用的堆空间，再然后是当前的堆容量，最后是GC持续的时间（以秒计）。&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM实用参数（七）CMS收集器</title>
    <link href="https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-7-cms-collector/"/>
    <id>https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-7-cms-collector/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2016-12-08T10:21:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自并发编程网 – ifeve.com本文链接地址: <a href="http://ifeve.com/useful-jvm-flags-part-7-cms-collector/" target="_blank" rel="external">JVM实用参数（七）CMS收集器</a><br>本文是<a href="http://ifeve.com" target="_blank" rel="external">并发编程网</a>经原国外blog作者授权的中文译文</p>
</blockquote>
<p><strong>译者:</strong> iDestiny<br><strong>校对:</strong> 梁海舰</p>
<p>HotSpot JVM的并发标记清理收集器(CMS收集器)的主要目标就是:低应用停顿时间。该目标对于大多数交互式应用很重要，比如web应用。在我们看一下有关JVM的参数之前,让我们简要回顾CMS收集器的操作和使用它时可能出现的主要挑战。</p>
<p>就像吞吐量收集器(参见本系列的第6部分),CMS收集器处理老年代的对象,然而其操作要复杂得多。吞吐量收集器总是暂停应用程序线程，并且可能是相当长的一段时间，然而这能够使该算法安全地忽略应用程序。相比之下，CMS收集器被设计成在大多数时间能与应用程序线程并行执行，仅仅会有一点(短暂的)停顿时间。GC与应用程序并行的缺点就是，可能会出现各种同步和数据不一致的问题。为了实现安全且正确的并发执行，CMS收集器的GC周期被分为了好几个连续的阶段。</p>
<a id="more"></a>
<h2 id="CMS收集器的过程"><a href="#CMS收集器的过程" class="headerlink" title="CMS收集器的过程"></a>CMS收集器的过程</h2><p>CMS收集器的GC周期由6个阶段组成。其中4个阶段(名字以Concurrent开始的)与实际的应用程序是并发执行的，而其他2个阶段需要暂停应用程序线程。</p>
<ol>
<li>初始标记:为了收集应用程序的对象引用需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动。</li>
<li>并发标记:从第一阶段收集到的对象引用开始，遍历所有其他的对象引用。</li>
<li>并发预清理:改变当运行第二阶段时，由应用程序线程产生的对象引用，以更新第二阶段的结果。</li>
<li>重标记:由于第三阶段是并发的，对象引用可能会发生进一步改变。因此，应用程序线程会再一次被暂停以更新这些变化，并且在进行实际的清理之前确保一个正确的对象引用视图。这一阶段十分重要，因为必须避免收集到仍被引用的对象。</li>
<li>并发清理:所有不再被应用的对象将从堆里清除掉。</li>
<li>并发重置:收集器做一些收尾的工作，以便下一次GC周期能有一个干净的状态。</li>
</ol>
<p>一个常见的误解是,CMS收集器运行是完全与应用程序并发的。我们已经看到，事实并非如此，即使“stop-the-world”阶段相对于并发阶段的时间很短。</p>
<p>应该指出，尽管CMS收集器为老年代垃圾回收提供了几乎完全并发的解决方案，然而年轻代仍然通过“stop-the-world”方法来进行收集。对于交互式应用，停顿也是可接受的，背后的原理是年轻带的垃圾回收时间通常是相当短的。</p>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>当我们在真实的应用中使用CMS收集器时，我们会面临两个主要的挑战，可能需要进行调优:</p>
<ol>
<li>堆碎片</li>
<li>对象分配率高</li>
</ol>
<p>堆碎片是有可能的，不像吞吐量收集器，CMS收集器并没有任何碎片整理的机制。因此，应用程序有可能出现这样的情形，即使总的堆大小远没有耗尽，但却不能分配对象——仅仅是因为没有足够连续的空间完全容纳对象。当这种事发生后，并发算法不会帮上任何忙，因此，万不得已JVM会触发Full GC。回想一下，Full GC 将运行吞吐量收集器的算法，从而解决碎片问题——但却暂停了应用程序线程。因此尽管CMS收集器带来完全的并发性，但仍然有可能发生长时间的“stop-the-world”的风险。这是“设计”，而不能避免的——我们只能通过调优收集器来它的可能性。想要100%保证避免”stop-the-world”，对于交互式应用是有问题的。</p>
<p>第二个挑战就是应用的对象分配率高。如果获取对象实例的频率高于收集器清除堆里死对象的频率，并发算法将再次失败。从某种程度上说，老年代将没有足够的可用空间来容纳一个从年轻代提升过来的对象。这种情况被称为“并发模式失败”，并且JVM会执行堆碎片整理:触发Full GC。</p>
<p>当这些情形之一出现在实践中时(经常会出现在生产系统中)，经常被证实是老年代有大量不必要的对象。一个可行的办法就是增加年轻代的堆大小，以防止年轻代短生命的对象提前进入老年代。另一个办法就似乎利用分析器，快照运行系统的堆转储，并且分析过度的对象分配，找出这些对象，最终减少这些对象的申请。</p>
<p>下面我看看大多数与CMS收集器调优相关的JVM标志参数。</p>
<h2 id="XX-UseConcMarkSweepGC"><a href="#XX-UseConcMarkSweepGC" class="headerlink" title="-XX:+UseConcMarkSweepGC"></a>-XX:+UseConcMarkSweepGC</h2><p>该标志首先是激活CMS收集器。默认HotSpot JVM使用的是并行收集器。</p>
<h2 id="XX-UseParNewGC"><a href="#XX-UseParNewGC" class="headerlink" title="-XX:UseParNewGC"></a>-XX:UseParNewGC</h2><p>当使用CMS收集器时，该标志激活年轻代使用多线程并行执行垃圾回收。这令人很惊讶，我们不能简单在并行收集器中重用-XX:UserParNewGC标志，因为概念上年轻代用的算法是一样的。然而，对于CMS收集器，年轻代GC算法和老年代GC算法是不同的，因此年轻代GC有两种不同的实现，并且是两个不同的标志。</p>
<p>注意最新的JVM版本，当使用-XX:+UseConcMarkSweepGC时，-XX:UseParNewGC会自动开启。因此，如果年轻代的并行GC不想开启，可以通过设置-XX:-UseParNewGC来关掉。</p>
<h2 id="XX-CMSConcurrentMTEnabled"><a href="#XX-CMSConcurrentMTEnabled" class="headerlink" title="-XX:+CMSConcurrentMTEnabled"></a>-XX:+CMSConcurrentMTEnabled</h2><p>当该标志被启用时，并发的CMS阶段将以多线程执行(因此，多个GC线程会与所有的应用程序线程并行工作)。该标志已经默认开启，如果顺序执行更好，这取决于所使用的硬件，多线程执行可以通过-XX:-CMSConcurremntMTEnabled禁用。</p>
<h2 id="XX-ConcGCThreads"><a href="#XX-ConcGCThreads" class="headerlink" title="-XX:ConcGCThreads"></a>-XX:ConcGCThreads</h2><p>标志-XX:ConcGCThreads=<value>(早期JVM版本也叫-XX:ParallelCMSThreads)定义并发CMS过程运行时的线程数。比如value=4意味着CMS周期的所有阶段都以4个线程来执行。尽管更多的线程会加快并发CMS过程，但其也会带来额外的同步开销。因此，对于特定的应用程序，应该通过测试来判断增加CMS线程数是否真的能够带来性能的提升。</value></p>
<p>如果还标志未设置，JVM会根据并行收集器中的-XX:ParallelGCThreads参数的值来计算出默认的并行CMS线程数。该公式是ConcGCThreads = (ParallelGCThreads + 3)/4。因此，对于CMS收集器， -XX:ParallelGCThreads标志不仅影响“stop-the-world”垃圾收集阶段，还影响并发阶段。</p>
<p>总之，有不少方法可以配置CMS收集器的多线程执行。正是由于这个原因,建议第一次运行CMS收集器时使用其默认设置, 然后如果需要调优再进行测试。只有在生产系统中测量(或类生产测试系统)发现应用程序的暂停时间的目标没有达到 , 就可以通过这些标志应该进行GC调优。</p>
<h2 id="XX-CMSInitiatingOccupancyFraction"><a href="#XX-CMSInitiatingOccupancyFraction" class="headerlink" title="-XX:CMSInitiatingOccupancyFraction"></a>-XX:CMSInitiatingOccupancyFraction</h2><p>当堆满之后，并行收集器便开始进行垃圾收集，例如，当没有足够的空间来容纳新分配或提升的对象。对于CMS收集器，长时间等待是不可取的，因为在并发垃圾收集期间应用持续在运行(并且分配对象)。因此，为了在应用程序使用完内存之前完成垃圾收集周期，CMS收集器要比并行收集器更先启动。</p>
<p>因为不同的应用会有不同对象分配模式，JVM会收集实际的对象分配(和释放)的运行时数据，并且分析这些数据，来决定什么时候启动一次CMS垃圾收集周期。为了引导这一过程， JVM会在一开始执行CMS周期前作一些线索查找。该线索由 -XX:CMSInitiatingOccupancyFraction=<value>来设置，该值代表老年代堆空间的使用率。比如，value=75意味着第一次CMS垃圾收集会在老年代被占用75%时被触发。通常CMSInitiatingOccupancyFraction的默认值为68(之前很长时间的经历来决定的)。</value></p>
<h2 id="XX-UseCMSInitiatingOccupancyOnly"><a href="#XX-UseCMSInitiatingOccupancyOnly" class="headerlink" title="-XX:+UseCMSInitiatingOccupancyOnly"></a>-XX:+UseCMSInitiatingOccupancyOnly</h2><p>我们用-XX+UseCMSInitiatingOccupancyOnly标志来命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期。而是，当该标志被开启时，JVM通过CMSInitiatingOccupancyFraction的值进行每一次CMS收集，而不仅仅是第一次。然而，请记住大多数情况下，JVM比我们自己能作出更好的垃圾收集决策。因此，只有当我们充足的理由(比如测试)并且对应用程序产生的对象的生命周期有深刻的认知时，才应该使用该标志。</p>
<h2 id="XX-CMSClassUnloadingEnabled"><a href="#XX-CMSClassUnloadingEnabled" class="headerlink" title="-XX:+CMSClassUnloadingEnabled"></a>-XX:+CMSClassUnloadingEnabled</h2><p>相对于并行收集器，CMS收集器默认不会对永久代进行垃圾回收。如果希望对永久代进行垃圾回收，可用设置标志-XX:+CMSClassUnloadingEnabled。在早期JVM版本中，要求设置额外的标志-XX:+CMSPermGenSweepingEnabled。注意，即使没有设置这个标志，一旦永久代耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC。</p>
<h2 id="XX-CMSIncrementalMode"><a href="#XX-CMSIncrementalMode" class="headerlink" title="-XX:+CMSIncrementalMode"></a>-XX:+CMSIncrementalMode</h2><p>该标志将开启CMS收集器的增量模式。增量模式经常暂停CMS过程，以便对应用程序线程作出完全的让步。因此，收集器将花更长的时间完成整个收集周期。因此，只有通过测试后发现正常CMS周期对应用程序线程干扰太大时，才应该使用增量模式。由于现代服务器有足够的处理器来适应并发的垃圾收集，所以这种情况发生得很少。</p>
<h2 id="XX-ExplicitGCInvokesConcurrent-and-XX-ExplicitGCInvokesConcurrentAndUnloadsClasses"><a href="#XX-ExplicitGCInvokesConcurrent-and-XX-ExplicitGCInvokesConcurrentAndUnloadsClasses" class="headerlink" title="-XX:+ExplicitGCInvokesConcurrent and -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses"></a>-XX:+ExplicitGCInvokesConcurrent and -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</h2><p>如今,被广泛接受的最佳实践是避免显式地调用GC(所谓的“系统GC”)，即在应用程序中调用system.gc()。然而，这个建议是不管使用的GC算法的，值得一提的是，当使用CMS收集器时，系统GC将是一件很不幸的事，因为它默认会触发一次Full GC。幸运的是，有一种方式可以改变默认设置。标志-XX:+ExplicitGCInvokesConcurrent命令JVM无论什么时候调用系统GC，都执行CMS GC，而不是Full GC。第二个标志-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses保证当有系统GC调用时，永久代也被包括进CMS垃圾回收的范围内。因此，通过使用这些标志，我们可以防止出现意料之外的”stop-the-world”的系统GC。</p>
<h2 id="XX-DisableExplicitGC"><a href="#XX-DisableExplicitGC" class="headerlink" title="-XX:+DisableExplicitGC"></a>-XX:+DisableExplicitGC</h2><p>然而在这个问题上…这是一个很好提到- XX:+ DisableExplicitGC标志的机会，该标志将告诉JVM完全忽略系统的GC调用(不管使用的收集器是什么类型)。对于我而言，该标志属于默认的标志集合中，可以安全地定义在每个JVM上运行，而不需要进一步思考。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自并发编程网 – ifeve.com本文链接地址: &lt;a href=&quot;http://ifeve.com/useful-jvm-flags-part-7-cms-collector/&quot;&gt;JVM实用参数（七）CMS收集器&lt;/a&gt;&lt;br&gt;本文是&lt;a href=&quot;http://ifeve.com&quot;&gt;并发编程网&lt;/a&gt;经原国外blog作者授权的中文译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;译者:&lt;/strong&gt; iDestiny&lt;br&gt;&lt;strong&gt;校对:&lt;/strong&gt; 梁海舰&lt;/p&gt;
&lt;p&gt;HotSpot JVM的并发标记清理收集器(CMS收集器)的主要目标就是:低应用停顿时间。该目标对于大多数交互式应用很重要，比如web应用。在我们看一下有关JVM的参数之前,让我们简要回顾CMS收集器的操作和使用它时可能出现的主要挑战。&lt;/p&gt;
&lt;p&gt;就像吞吐量收集器(参见本系列的第6部分),CMS收集器处理老年代的对象,然而其操作要复杂得多。吞吐量收集器总是暂停应用程序线程，并且可能是相当长的一段时间，然而这能够使该算法安全地忽略应用程序。相比之下，CMS收集器被设计成在大多数时间能与应用程序线程并行执行，仅仅会有一点(短暂的)停顿时间。GC与应用程序并行的缺点就是，可能会出现各种同步和数据不一致的问题。为了实现安全且正确的并发执行，CMS收集器的GC周期被分为了好几个连续的阶段。&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM GC</title>
    <link href="https://www.deleiguo.com/2016/10/08/jvm-gc/"/>
    <id>https://www.deleiguo.com/2016/10/08/jvm-gc/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2017-02-09T09:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>参考书籍：<a href="https://book.douban.com/subject/25953851/" target="_blank" rel="external">深入分析Java Web技术内幕（修订版）</a></p>
</blockquote>
<h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><div class="table-container">
<table>
<thead>
<tr>
<th>GC组合</th>
<th>Young区</th>
<th>Old区</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseSerialGC</td>
<td>串行GC</td>
<td>串行GC</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>PSGC</td>
<td>并行MSCGC</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>并行GC</td>
<td>串行GC</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>PSGC</td>
<td>并行CompactingGC</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>ParNewGC</td>
<td>并行GC<br>当出现concurrentMOde failure时采用串行GC</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC<br>-XX:+UseParNewGC</td>
<td>串行GC</td>
<td>并行GC<br>当出现concurrentMOde failure或promotionfailed采用串行GC</td>
</tr>
</tbody>
</table>
</div>
<p>不支持的组合方式：<br>(1)-XX:+UseParNewGC -XX:+UseParallelOldGC<br>(1)-XX:+UseParNewGC -XX:+UseSerialGC</p>
<a id="more"></a>
<h2 id="参数列表集合"><a href="#参数列表集合" class="headerlink" title="参数列表集合"></a>参数列表集合</h2><div class="table-container">
<table>
<thead>
<tr>
<th>GC方式</th>
<th>参数集合</th>
</tr>
</thead>
<tbody>
<tr>
<td>Heep堆配置</td>
<td><ul><li>-Xms 堆初始大小</li><li>-Xmx 堆最大值</li><li>-Xmn Young区大小</li><li>-XX:PermSize Perm区大小</li><li>-XX:MaxPermSize Perm区最大值</li></ul></td>
</tr>
<tr>
<td>Serial Collector(串行)</td>
<td><ul><li>-XX:+UseSerialGC GC方式</li><li>-XX:+SurvivorRatio 默认为8,代表eden:s0</li><li>-XX:MaxTenuringThreshold 默认为15,代表对象在新生代经历多少次MinorGC后才晋升到Old区,效率高,当Heap过大时,应用程序暂停时间较长</li></ul></td>
</tr>
<tr>
<td>(并行)Parallel Collector-ParNewGC</td>
<td><ul><li>-XX:+UseParNewGC</li><li>-XX:+SurvivorRatio 默认为8,代表eden:s0</li><li>-XX:MaxTenuringThreshold 默认为15</li><li>-XX:+UseAdaptiveSizePolicy</li></ul></td>
</tr>
<tr>
<td>(并行)Parallel Collector-ParallelGC</td>
<td><ul><li>-XX:+UseParallelGC</li><li>-XX:+ParallelGCThreads 并发线程数</li><li>-XX:InitialSurivivorRatio 默认为8,Young:s0的比</li><li>-XX:+UseAdaptiveSizePolicy</li><li>-XX:MaxTenuringThreshold 默认为15</li><li>-XX:+ScavengeBeforeFullGC FullGC前触发MinorGC</li></ul></td>
</tr>
<tr>
<td>(并行)Parallel Collector-ParallelOldGC</td>
<td><ul><li>-XX:+UseParallelOldGC </li></ul></td>
</tr>
<tr>
<td>(并发)CMS Collector</td>
<td><ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:ParallelCMSThreads 设置并发CMS GC时的线程数</li><li>-XX:CMSInitiatingOccupancyFraction 当旧生代使用占到多少百分比时触发CMS GC</li><li>-XX:+UseCMSInitiatingOccupancyOnly 默认为false,代表允许hotspot根据成本来决定什么时候执行CMS GC</li><li>-XX:+UseCMSCompactAtFullCollection 当Full GC时执行压缩</li><li>-XX:CMSMaxAbortablePrecleanTime=5000 设置preclean步骤的超时事件,单位为毫秒</li><li>-XX:+CMSClassUnloadingEnabled PermGen采用CMS GC</li></ul></td>
</tr>
</tbody>
</table>
</div>
<h2 id="三种GC优缺对比"><a href="#三种GC优缺对比" class="headerlink" title="三种GC优缺对比"></a>三种GC优缺对比</h2><div class="table-container">
<table>
<thead>
<tr>
<th>GC</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial Collector(串行)</td>
<td>在适合内存有限的情况下</td>
<td>回收慢</td>
</tr>
<tr>
<td>Parallel Collector(并发)</td>
<td>效率高</td>
<td>当Heap过大时,应用程序暂停时间较长</td>
</tr>
<tr>
<td>CMS Collector(并发)</td>
<td>Old区回收暂停时间短</td>
<td>产生内存碎片、整个GC耗时较长,比较耗CPU</td>
</tr>
</tbody>
</table>
</div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考书籍：&lt;a href=&quot;https://book.douban.com/subject/25953851/&quot;&gt;深入分析Java Web技术内幕（修订版）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;组合使用&quot;&gt;&lt;a href=&quot;#组合使用&quot; class=&quot;headerlink&quot; title=&quot;组合使用&quot;&gt;&lt;/a&gt;组合使用&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;GC组合&lt;/th&gt;
&lt;th&gt;Young区&lt;/th&gt;
&lt;th&gt;Old区&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseSerialGC&lt;/td&gt;
&lt;td&gt;串行GC&lt;/td&gt;
&lt;td&gt;串行GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseParallelGC&lt;/td&gt;
&lt;td&gt;PSGC&lt;/td&gt;
&lt;td&gt;并行MSCGC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseParNewGC&lt;/td&gt;
&lt;td&gt;并行GC&lt;/td&gt;
&lt;td&gt;串行GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseParallelOldGC&lt;/td&gt;
&lt;td&gt;PSGC&lt;/td&gt;
&lt;td&gt;并行CompactingGC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseConcMarkSweepGC&lt;/td&gt;
&lt;td&gt;ParNewGC&lt;/td&gt;
&lt;td&gt;并行GC&lt;br&gt;当出现concurrentMOde failure时采用串行GC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseConcMarkSweepGC&lt;br&gt;-XX:+UseParNewGC&lt;/td&gt;
&lt;td&gt;串行GC&lt;/td&gt;
&lt;td&gt;并行GC&lt;br&gt;当出现concurrentMOde failure或promotionfailed采用串行GC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;不支持的组合方式：&lt;br&gt;(1)-XX:+UseParNewGC -XX:+UseParallelOldGC&lt;br&gt;(1)-XX:+UseParNewGC -XX:+UseSerialGC&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux Command：命令帮助</title>
    <link href="https://www.deleiguo.com/2016/10/08/linux-command-help/"/>
    <id>https://www.deleiguo.com/2016/10/08/linux-command-help/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2016-12-08T10:50:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>指导环境：CentOS7</p>
</blockquote>
<h2 id="Linux命令数量"><a href="#Linux命令数量" class="headerlink" title="Linux命令数量"></a>Linux命令数量</h2><p>在Linux下，如果不记得命令的全称，但知道前面几个字母，可以通过tab自动补全，或按下两次tab列出相符的多个可选项；</p>
<pre><code class="lang-bash">[root@delei-server ~]# ls
ls        lscgroup  lsinitrd  lsmcli    lsof      lssubsys
lsattr    lscpu     lslocks   lsmd      lspci     lsusb
lsblk     lsdiff    lslogins  lsmod     lsscsi    lsusb.py
</code></pre>
<p>而当匹配的数量过多，会先先统计有多少数量，询问是否显示</p>
<pre><code class="lang-bash">[root@delei-server ~]# c
Display all 199 possibilities? (y or n)
</code></pre>
<a id="more"></a>
<p>那么，我们可以在不输入任何字的情况下，直接按下两次tab键，则可以统计下当前用户下可用的命令有多少个.</p>
<blockquote>
<p>但是经过实际尝试，在CenOS7下，该方法无效,Mac下有效</p>
</blockquote>
<pre><code class="lang-bash">delei@DeleitekiMBP:~$
Display all 1473 possibilities? (y or n)
</code></pre>
<blockquote>
<p>每个人的操作系统所用的命令数都是不一样的。<br>不同的linux版本，用户安装的软件命令，用户设置的环境变量等都是不一样的。</p>
</blockquote>
<p>虽然经常常用的命令数量不多，但是在有些情况下，很多命令的详细参数和选项用法不一定都能记得住。而若在无网络，无参考手册情况下，更会遇到不知道如何使用命令的情况。Linux上开发的软件大多数是自由性软件，而这些软件开发者一般都会有相应的命令使用方法。<br>在上述情况下，其实Linux已提供了几种方式能够提供帮助。</p>
<h2 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h2><p>该命令获得索引的简短信息,如果有多个匹配(不同版本，多个同样的软件等)则会列出多个</p>
<pre><code class="lang-bash">[root@delei-server ~]# whatis cd
cd (1)               - bash built-in commands, see bash(1)
cd (1p)              - change the working directory
[root@delei-server ~]# whatis wget
wget (1)             - The non-interactive network downloader.
</code></pre>
<p>但不是所有命令在所有的Linux上均可使用</p>
<pre><code class="lang-bash">[root@delei-server ~]# whatis ll
ll：没有 appropriate。
</code></pre>
<h2 id="help、-help"><a href="#help、-help" class="headerlink" title="help、-help"></a>help、-help</h2><p>—help该命令显示使用摘要和参数列表，可以查看大多数命令的用法</p>
<pre><code class="lang-bash">[root@delei-server ~]# date --help
用法：date [选项]... [+格式]
　或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]
Display the current time in the given FORMAT, or set the system date.

Mandatory arguments to long options are mandatory for short options too.
  -d, --date=STRING         display time described by STRING, not &#39;now&#39;
  -f, --file=DATEFILE       like --date once for each line of DATEFILE
  -I[TIMESPEC], --iso-8601[=TIMESPEC]  output date/time in ISO 8601 format.
                            TIMESPEC=&#39;date&#39; for date only (the default),
                            &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, or &#39;ns&#39; for date
                            and time to the indicated precision.
  -r, --reference=文件        显示文件指定文件的最后修改时间
  -R, --rfc-2822        以RFC 2822格式输出日期和时间
                例如：2006年8月7日，星期一 12:34:56 -0600
      --rfc-3339=TIMESPEC   output date and time in RFC 3339 format.
                            TIMESPEC=&#39;date&#39;, &#39;seconds&#39;, or &#39;ns&#39; for
                            date and time to the indicated precision.
                            Date and time components are separated by
                            a single space: 2006-08-07 12:34:56-06:00
  -s, --set=STRING          set time described by STRING
  -u, --utc, --universal    print or set Coordinated Universal Time (UTC)
      --help        显示此帮助信息并退出
      --version        显示版本信息并退出

给定的格式FORMAT 控制着输出，解释序列如下：

  %%    一个文字的 %
  %a    当前locale 的星期名缩写(例如： 日，代表星期日)
  %A    当前locale 的星期名全称 (如：星期日)
  %b    当前locale 的月名缩写 (如：一，代表一月)
  %B    当前locale 的月名全称 (如：一月)
  ...

默认情况下，日期的数字区域以0 填充。
The following optional flags may follow &#39;%&#39;:

  -  (hyphen) do not pad the field
  _  (underscore) pad with spaces
  0  (zero) pad with zeros
  ^  use upper case if possible
  #  use opposite case if possible

在任何标记之后还允许一个可选的域宽度指定，它是一个十进制数字。
作为一个可选的修饰声明，它可以是E，在可能的情况下使用本地环境关联的
表示方式；或者是O，在可能的情况下使用本地环境关联的数字符号。

Examples:
Convert seconds since the epoch (1970-01-01 UTC) to a date
  $ date --date=&#39;@2147483647&#39;

Show the time on the west coast of the US (use tzselect(1) to find TZ)
  $ TZ=&#39;America/Los_Angeles&#39; date

Show the local time for 9AM next Friday on the west coast of the US
  $ date --date=&#39;TZ=&quot;America/Los_Angeles&quot; 09:00 next Fri&#39;

GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;
请向&lt;http://translationproject.org/team/zh_CN.html&gt; 报告date 的翻译错误
要获取完整文档，请运行：info coreutils &#39;date invocation&#39;
</code></pre>
<p>—help只能对外部命令使用，对内部命令无效当我们要求内部命令的帮助时使用help+命令</p>
<pre><code class="lang-bash">[root@delei-server bin]# help pwd
pwd: pwd [-LP]
    打印当前工作目录的名字。

    选项：
      -L    打印 $PWD 变量的值，如果它命名了当前的
        工作目录
      -P    打印当前的物理路径，不带有任何的符号链接

    默认情况下，`pwd&#39; 的行为和带 `-L&#39; 选项一致

    退出状态：
    除非使用了无效选项或者当前目录不可读，否则
    返回状态为0。
</code></pre>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>man是manual的简写，命令使用手册／说明<br>同样是pwd,man提供的内容较多(内容过长，部分已省略…)</p>
<pre><code class="lang-bash">[root@delei-server bin]# man date
DATE(1)                       User Commands                      DATE(1)

NAME
       date - print or set the system date and time

SYNOPSIS
       date [OPTION]... [+FORMAT]
       date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]

DESCRIPTION
       Display  the  current time in the given FORMAT, or set the system
       date.

       Mandatory arguments to  long  options  are  mandatory  for  short
       options too.

       -d, --date=STRING
              display time described by STRING, not &#39;now&#39;

       -f, --file=DATEFILE
              like --date once for each line of DATEFILE

       -I[TIMESPEC], --iso-8601[=TIMESPEC]
              output  date/time in ISO 8601 format.  TIMESPEC=&#39;date&#39; for
              date only (the default), &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, or
              &#39;ns&#39; for date and time to the indicated precision.

       ...
       #      use opposite case if possible

       After any flags comes an optional field width, as a decimal  num‐
       ber;  then  an  optional  modifier,  which is either E to use the
       locale&#39;s alternate representations if available, or O to use  the
       locale&#39;s alternate numeric symbols if available.

ENVIRONMENT
       TZ     Specifies  the timezone, unless overridden by command line
              parameters.  If neither is  specified,  the  setting  from
              /etc/localtime is used.

EXAMPLES
       Convert seconds since the epoch (1970-01-01 UTC) to a date

              $ date --date=&#39;@2147483647&#39;

       Show  the  time  on  the west coast of the US (use tzselect(1) to
       find TZ)

              $ TZ=&#39;America/Los_Angeles&#39; date
    ...

DATE STRING
       The  --date=STRING  is  a  mostly free format human readable date
       string such as &quot;Sun, 29 Feb 2004 16:21:42 -0800&quot;  or  &quot;2004-02-29
       16:21:42&quot;  or  even  &quot;next  Thursday&quot;.  A date string may contain
       items indicating calendar date, time of day, time  zone,  day  of
       week, relative time, relative date, and numbers.  An empty string
       indicates the beginning of the day.  The date  string  format  is
       more  complex  than  is  easily  documented  here  but  is  fully
       described in the info documentation.

AUTHOR
       Written by David MacKenzie.

COPYRIGHT
       Copyright © 2013 Free Software Foundation, Inc.  License  GPLv3+:
       GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;.
       This  is  free  software: you are free to change and redistribute
       it.  There is NO WARRANTY, to the extent permitted by law.

SEE ALSO
       The full documentation for date is maintained as a  Texinfo  man‐
       ual.   If  the  info  and date programs are properly installed at
       your site, the command

              info coreutils &#39;date invocation&#39;

       should give you access to the complete manual.

GNU coreutils 8.22            February 2016                      DATE(1)
 Manual page date(1) line 159/222 (END) (press h for help or q to quit)
</code></pre>
<blockquote>
<p>当内容较多时，使用page up和page down上下翻页，空格也可向下翻页;<br>按q退出</p>
</blockquote>
<p>在man的帮助手册中，将帮助文档分为了9个类别，对于有的关键字可能存在多个类别中， 我们就需要指定特定的类别来查看；（一般我们查询bash命令，归类在1类中）；</p>
<h4 id="man页面所属的分类标识-常用的是1、3、5、8"><a href="#man页面所属的分类标识-常用的是1、3、5、8" class="headerlink" title="man页面所属的分类标识(常用的是1、3、5、8)"></a>man页面所属的分类标识(常用的是1、3、5、8)</h4><ol>
<li>用户可以操作的命令或者是可执行文件</li>
<li>系统核心可调用的函数与工具等</li>
<li>一些常用的函数与数据库</li>
<li>设备文件的说明</li>
<li>设置文件或者某些文件的格式</li>
<li>游戏</li>
<li>惯例与协议等。例如Linux标准文件系统、网络协议、ASCⅡ，码等说明内容</li>
<li>系统管理员可用的管理条令</li>
<li>与内核有关的文件</li>
</ol>
<h4 id="man-page的常见部分"><a href="#man-page的常见部分" class="headerlink" title="man page的常见部分"></a>man page的常见部分</h4><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>内容说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME</td>
<td>简短的指令、资料名称说明</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>简短的指令下达语法简介</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>较为完整的说明</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>针对SYNOPSI部分，有列举的所有可用的选项说明</td>
</tr>
<tr>
<td>COMMANDS</td>
<td>当该命令在运行的时候，可以下达的命令</td>
</tr>
<tr>
<td>FILES</td>
<td>使用或链接到的某些档案／文件</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>可以参考的，跟该命令或资料有相关的其他说明</td>
</tr>
<tr>
<td>EXAMPLE</td>
<td>可以参考的范例</td>
</tr>
<tr>
<td>AUTHORS</td>
<td>作者</td>
</tr>
<tr>
<td>COPYRIGHT</td>
<td>版权说明</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>这是常见的内容，实际上还有其他部分<br>在某些命令中这些内容不全都有</p>
</blockquote>
<h4 id="man常用命令参数"><a href="#man常用命令参数" class="headerlink" title="man常用命令参数"></a>man常用命令参数</h4><ul>
<li><p>man -a：<br>搜索并打开所有man中同名帮助，例如 man passwd ，你首先会进入一个PASSWD(1) section用户命令类的帮助手册，你再按q键退出当前正在显示的帮助手册，就会进入PASSWD(5) section文件格式类的帮助手册。</p>
</li>
<li><p>man -aw：<br>显示所有手册文件的路径。</p>
</li>
</ul>
<pre><code class="lang-bash">[root@delei-server bin]# man -aw passwd
/usr/share/man/man1/passwd.1.gz
/usr/share/man/man1/sslpasswd.1ssl.gz
/usr/share/man/man5/passwd.5.gz
</code></pre>
<ul>
<li><p>man -M：<br>指定手册文件的搜索路径，有的时候我们自己安装的软件是带有自己的帮助文件的，通常不在我们的MANPATH里面，那么我们就可以手动指定man搜索的文件路径。如 man -M /home/mysql/man mysql显示的就是你安装的mysql的帮助，而不是系统默认的旧版mysql的帮助。</p>
</li>
<li><p>man -k：<br>根据关键字搜索联机帮助，是一种模糊搜索。例如要查找”passwd”相关的信息，使用man -k passwd会找到很多和passwd相关的帮助页。如：我忘记了iptables命令就只能记住ipta则可以使用man -k ipta ，系统会把包括ipta的命令显示在屏幕上。</p>
</li>
</ul>
<pre><code class="lang-bash">[root@delei-server bin]# man -k passwd
chpasswd (8)         - 批量更新密码
gpasswd (1)          - 管理员 /etc/group 和 /etc/gshadow
fgetpwent_r (3)      - get passwd file entry reentrantly
getpwent_r (3)       - get passwd file entry reentrantly
grub2-mkpasswd-pbkdf2 (1) - Generate a PBKDF2 password hash.
htpasswd (1)         - Manage user files for basic authentication
kpasswd (1)          - change a user&#39;s Kerberos password
ldappasswd (1)       - change the password of an LDAP entry
lpasswd (1)          - Change group or user password
lppasswd (1)         - add, change, or delete digest passwords.
pam_localuser (8)    - require users to be listed in /etc/passwd
passwd (1)           - update user&#39;s authentication tokens
sslpasswd (1ssl)     - compute password hashes
passwd (5)           - password file
passwd2des (3)       - RFS password encryption
pwhistory_helper (8) - Helper binary that transfers password hashes fro...
saslpasswd2 (8)      - set a user&#39;s sasl password
smbpasswd (5)        - The Samba encrypted password file
smbpasswd (8)        - change a user&#39;s SMB password
vncpasswd (1)        - change the VNC password
</code></pre>
<ul>
<li>man -f：<br>关键字精确搜索，与-k不同，它只搜索与关键字完全匹配的帮助页。</li>
</ul>
<pre><code class="lang-bash">[root@delei-server bin]# man -f passwd
sslpasswd (1ssl)     - compute password hashes
passwd (1)           - update user&#39;s authentication tokens
passwd (5)           - password file
</code></pre>
<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>info与man类似，也是一种帮助说明,指令的文件预设放在<code>/usr/share/info/</code>目录中。<br>与man不同的是，info不是都在一个页面显示，而是将文件资料拆成了多个段落，每个段落有自己的页面，并且在各个页面还有类似链接的方式可以跳转，每个页面被称为一个node.</p>
<pre><code class="lang-bash">[root@delei-server bin]# info info
File: info.info,  Node: Top,  Next: Getting Started,  Up: (dir)

Info: An Introduction
*********************

The GNU Project distributes most of its on-line manuals in the &quot;Info
format&quot;, which you read using an &quot;Info reader&quot;.  You are probably using
an Info reader to read this now.

   ...

* Menu:

* Getting Started::             Getting started using an Info reader.
* Advanced::                    Advanced Info commands.
* Expert Info::                 Info commands for experts.
* Index::                       An index of topics, commands, and variabl\
es.
</code></pre>
<p>第一行:</p>
<ul>
<li>File：表示该info的内容是由info.info提供</li>
<li>Node：代表当前的这个页面是top</li>
<li>Next：下一个页面</li>
<li>Up：上一个页面</li>
</ul>
<p>将光标移动到该页面最下面”Menu”的列表部分，在每一个种，按下回车即可进入到相应的Node(类似于网页的链接跳转)</p>
<pre><code class="lang-bash">File: info.info,  Node: Advanced,  Next: Expert Info,  Prev: Getting Star\
ted,  Up: Top

2 Advanced Info Commands
************************

This chapter describes various advanced Info commands.  (If you are
using a stand-alone Info reader, there are additional commands specific
to it, which are documented in several chapters of *note GNU Info:
(info-stnd)Top.)

   ...

* Menu:

* Search Text::          How to search Info documents.
* Search Index::         How to search the indices for specific subjects.
* Go to node::           How to go to a node by name.
* Choose menu subtopic:: How to choose a menu subtopic by its number.
* Create Info buffer::   How to create a new Info buffer in Emacs.
* Emacs Info Variables:: Variables modifying the behavior of Emacs Info.
</code></pre>
<p>依照Menu可以进行node间的跳转，比起man来说，阅读更加方便</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://linux.vbird.org/linux_basic/0160startlinux.php#manual" target="_blank" rel="external">鸟哥的私房菜</a></li>
<li><a href="http://man.linuxde.net/" target="_blank" rel="external">Linux命令查询</a></li>
<li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/base/01_use_man.html" target="_blank" rel="external">Linux Tools Quick Tutorial</a></li>
<li><a href="http://www.dabu.info/linux-get-help-man-whatis-info-apropos.html" target="_blank" rel="external">大步’s Blog</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;指导环境：CentOS7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Linux命令数量&quot;&gt;&lt;a href=&quot;#Linux命令数量&quot; class=&quot;headerlink&quot; title=&quot;Linux命令数量&quot;&gt;&lt;/a&gt;Linux命令数量&lt;/h2&gt;&lt;p&gt;在Linux下，如果不记得命令的全称，但知道前面几个字母，可以通过tab自动补全，或按下两次tab列出相符的多个可选项；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;[root@delei-server ~]# ls
ls        lscgroup  lsinitrd  lsmcli    lsof      lssubsys
lsattr    lscpu     lslocks   lsmd      lspci     lsusb
lsblk     lsdiff    lslogins  lsmod     lsscsi    lsusb.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而当匹配的数量过多，会先先统计有多少数量，询问是否显示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;[root@delei-server ~]# c
Display all 199 possibilities? (y or n)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="Linux" scheme="https://www.deleiguo.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java 8新特性终极指南</title>
    <link href="https://www.deleiguo.com/2016/10/08/java-8-features-tutorial/"/>
    <id>https://www.deleiguo.com/2016/10/08/java-8-features-tutorial/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2016-12-12T09:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自importnew本文链接地址: <a href="http://www.importnew.com/11908.html" target="_blank" rel="external">Java 8新特性终极指南</a><br>本文为译文，推荐看原文：<a href="https://www.javacodegeeks.com/2014/05/java-8-features-tutorial.html" target="_blank" rel="external">Java 8 Features Tutorial – The ULTIMATE Guide</a></p>
<p>ps:原文可能要翻墙.</p>
<p>JDK8其实已问世很久了。JDK9也即将到来，截止该文章发布时，JDK8也还没有在大部分的环境中大量使用。在本人当前所在公司,JDK7还是主流，部分老框架项目还在用着JDK6</p>
</blockquote>
<p>[TOC]</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>毫无疑问，Java 8发行版是自Java 5（发行于2004，已经过了相当一段时间了）以来最具革命性的版本。Java 8 为Java语言、编译器、类库、开发工具与JVM（Java虚拟机）带来了大量新特性。在这篇教程中，我们将一一探索这些变化，并用真实的例子说明它们适用的场景。</p>
<p>这篇教程由以下几部分组成，它们分别涉及到Java平台某一特定方面的内容：</p>
<a id="more"></a>
<ul>
<li>Java语言</li>
<li>编译器</li>
<li>类库</li>
<li>工具</li>
<li>Java运行时（JVM）</li>
</ul>
<h2 id="Java语言的新特性"><a href="#Java语言的新特性" class="headerlink" title="Java语言的新特性"></a>Java语言的新特性</h2><p>不管怎么说，Java 8都是一个变化巨大的版本。你可能认为Java 8耗费了大量的时间才得以完成是为了实现了每个Java程序员所期待的特性。在这个小节里，我们将会涉及到这些特性的大部分。</p>
<h3 id="Lambda表达式与Functional接口"><a href="#Lambda表达式与Functional接口" class="headerlink" title="Lambda表达式与Functional接口"></a>Lambda表达式与Functional接口</h3><p>Lambda表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据：函数式程序员对这一概念非常熟悉。在JVM平台上的很多语言（Groovy，Scala，……）从一开始就有Lambda，但是Java程序员不得不使用毫无新意的匿名类来代替lambda。</p>
<p>关于Lambda设计的讨论占用了大量的时间与社区的努力。可喜的是，最终找到了一个平衡点，使得可以使用一种即简洁又紧凑的新方式来构造Lambdas。在最简单的形式中，一个lambda可以由用逗号分隔的参数列表、–&gt;符号与函数体三部分表示。例如：</p>
<pre><code class="lang-java">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.println( e ) );
</code></pre>
<p>请注意参数e的类型是由编译器推测出来的。同时，你也可以通过把参数类型与参数包括在括号中的形式直接给出参数的类型：</p>
<pre><code class="lang-java">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.println( e ) );
</code></pre>
<p>在某些情况下lambda的函数体会更加复杂，这时可以把函数体放到在一对花括号中，就像在Java中定义普通函数一样。例如：</p>
<pre><code class="lang-java">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; {
    System.out.print( e );
    System.out.print( e );
} );
</code></pre>
<p>Lambda可以引用类的成员变量与局部变量（如果这些变量不是final的话，它们会被隐含的转为final，这样效率更高）。例如，下面两个代码片段是等价的：</p>
<pre><code class="lang-java">String separator = &quot;,&quot;;
Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(
    ( String e ) -&gt; System.out.print( e + separator ) );
</code></pre>
<p>和</p>
<pre><code class="lang-java">final String separator = &quot;,&quot;;
Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(
    ( String e ) -&gt; System.out.print( e + separator ) );
</code></pre>
<p>语言设计者投入了大量精力来思考如何使现有的函数友好地支持lambda。最终采取的方法是：增加函数式接口的概念。函数式接口就是一个具有一个方法的普通接口。像这样的接口，可以被隐式转换为lambda表达式。java.lang.Runnable与java.util.concurrent.Callable是函数式接口最典型的两个例子。在实际使用过程中，函数式接口是容易出错的：如有某个人在接口定义中增加了另一个方法，这时，这个接口就不再是函数式的了，并且编译过程也会失败。为了克服函数式接口的这种脆弱性并且能够明确声明接口作为函数式接口的意图，Java 8增加了一种特殊的注解<code>@FunctionalInterface</code>（Java 8中所有类库的已有接口都添加了<code>@FunctionalInterface</code>注解）。让我们看一下这种函数式接口的定义：</p>
<pre><code class="lang-java">@FunctionalInterface
public interface Functional {
    void method();
}
</code></pre>
<p>需要记住的一件事是：默认方法与静态方法并不影响函数式接口的契约，可以任意使用：</p>
<pre><code class="lang-java">@FunctionalInterface
public interface FunctionalDefaultMethods {
    void method();

    default void defaultMethod() {
    }
}
</code></pre>
<p>Lambda是Java 8最大的卖点。它具有吸引越来越多程序员到Java平台上的潜力，并且能够在纯Java语言环境中提供一种优雅的方式来支持函数式编程。更多详情可以参考<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="接口的默认方法与静态方法"><a href="#接口的默认方法与静态方法" class="headerlink" title="接口的默认方法与静态方法"></a>接口的默认方法与静态方法</h3><p>Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。默认方法使接口有点像Traits（Scala中特征(trait)类似于Java中的Interface，但它可以包含实现代码，也就是目前Java8新增的功能），但与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。</p>
<p>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：</p>
<pre><code class="lang-java">private interface Defaulable {
    // Interfaces now allow default methods, the implementer may or
    // may not implement (override) them.
    default String notRequired() {
        return &quot;Default implementation&quot;;
    }
}

private static class DefaultableImpl implements Defaulable {
}

private static class OverridableImpl implements Defaulable {
    @Override
    public String notRequired() {
        return &quot;Overridden implementation&quot;;
    }
}
</code></pre>
<p>Defaulable接口用关键字default声明了一个默认方法notRequired()，Defaulable接口的实现者之一DefaultableImpl实现了这个接口，并且让默认方法保持原样。Defaulable接口的另一个实现者OverridableImpl用自己的方法覆盖了默认方法。</p>
<p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。例如：</p>
<pre><code class="lang-java">private interface DefaulableFactory {
    // Interfaces now allow static methods
    static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) {
        return supplier.get();
    }
}
</code></pre>
<p>下面的一小段代码片段把上面的默认方法与静态方法黏合到一起:</p>
<pre><code class="lang-java">public static void main( String[] args ) {
    Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new );
    System.out.println( defaulable.notRequired() );

    defaulable = DefaulableFactory.create( OverridableImpl::new );
    System.out.println( defaulable.notRequired() );
}
</code></pre>
<p>这个程序的控制台输出如下：</p>
<pre><code class="lang-bash">Default implementation
Overridden implementation
</code></pre>
<p>在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到java.util.Collection接口中去：stream()，parallelStream()，forEach()，removeIf()，……</p>
<p>尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法，因为默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。更多详情请参考<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>下面，我们以定义了4个方法的Car这个类作为例子，区分Java中支持的4种不同的方法引用:</p>
<pre><code class="lang-java">public static class Car {
    public static Car create( final Supplier&lt; Car &gt; supplier ) {
        return supplier.get();
    }

    public static void collide( final Car car ) {
        System.out.println( &quot;Collided &quot; + car.toString() );
    }

    public void follow( final Car another ) {
        System.out.println( &quot;Following the &quot; + another.toString() );
    }

    public void repair() {
        System.out.println( &quot;Repaired &quot; + this.toString() );
    }
}
</code></pre>
<p>第一种方法引用是构造器引用，它的语法是Class::new，或者更一般的Class&lt; T &gt;::new。请注意构造器没有参数。</p>
<pre><code class="lang-java">final Car car = Car.create( Car::new );
final List&lt; Car &gt; cars = Arrays.asList( car );
</code></pre>
<p>第二种方法引用是静态方法引用，它的语法是Class::static_method。请注意这个方法接受一个Car类型的参数。</p>
<pre><code class="lang-java">cars.forEach( Car::collide );
</code></pre>
<p>第三种方法引用是特定类的任意对象的方法引用，它的语法是Class::method。请注意，这个方法没有参数。</p>
<pre><code class="lang-java">cars.forEach( Car::repair );
</code></pre>
<p>最后，第四种方法引用是特定对象的方法引用，它的语法是instance::method。请注意，这个方法接受一个Car类型的参数</p>
<pre><code class="lang-java">final Car police = Car.create( Car::new );
cars.forEach( police::follow );
</code></pre>
<p>运行上面的Java程序在控制台上会有下面的输出（Car的实例可能不一样）：</p>
<pre><code class="lang-java">Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d
Repaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d
Following the com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d
</code></pre>
<p>关于方法引用的更多详情请参考<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h3><p>自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。</p>
<p>重复注解机制本身必须用@Repeatable注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：</p>
<pre><code class="lang-java">package com.javacodegeeks.java8.repeatable.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

public class RepeatingAnnotations {
    @Target( ElementType.TYPE )
    @Retention( RetentionPolicy.RUNTIME )
    public @interface Filters {
        Filter[] value();
    }

    @Target( ElementType.TYPE )
    @Retention( RetentionPolicy.RUNTIME )
    @Repeatable( Filters.class )
    public @interface Filter {
        String value();
    };

    @Filter( &quot;filter1&quot; )
    @Filter( &quot;filter2&quot; )
    public interface Filterable {
    }

    public static void main(String[] args) {
        for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) {
            System.out.println( filter.value() );
        }
    }
}
</code></pre>
<p>正如我们看到的，这里有个使用@Repeatable( Filters.class )注解的注解类Filter，Filters仅仅是Filter注解的数组，但Java编译器并不想让程序员意识到Filters的存在。这样，接口Filterable就拥有了两次Filter（并没有提到Filter）注解。</p>
<p>同时，反射相关的API提供了新的函数<code>getAnnotationsByType()</code>来返回重复注解的类型（请注意<code>Filterable.class.getAnnotation(Filters.class)</code>经编译器处理后将会返回Filters的实例）。</p>
<p>程序输出结果如下：</p>
<pre><code class="lang-java">filter1
filter2
</code></pre>
<p>更多详情请参考<a href="http://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="更好的类型推测机制"><a href="#更好的类型推测机制" class="headerlink" title="更好的类型推测机制"></a>更好的类型推测机制</h3><p>Java 8在类型推测方面有了很大的提高。在很多情况下，编译器可以推测出确定的参数类型，这样就能使代码更整洁。让我们看一个例子：</p>
<pre><code class="lang-java">package com.javacodegeeks.java8.type.inference;

public class Value&lt; T &gt; {
    public static&lt; T &gt; T defaultValue() {
        return null;
    }
         public T getOrDefault( T value, T defaultValue ) {
        return ( value != null ) ? value : defaultValue;
    }
}
</code></pre>
<p>这里是<code>Value&lt;String&gt;</code>类型的用法。</p>
<pre><code class="lang-java">package com.javacodegeeks.java8.type.inference;

public class TypeInference {
    public static void main(String[] args) {
        final Value&lt; String &gt; value = new Value&lt;&gt;();
        value.getOrDefault( &quot;22&quot;, Value.defaultValue() );
    }
}
</code></pre>
<p>Value.defaultValue()的参数类型可以被推测出，所以就不必明确给出。在Java 7中，相同的例子将不会通过编译，正确的书写方式是 Value.&lt; String &gt;defaultValue()。</p>
<h3 id="扩展注解的支持"><a href="#扩展注解的支持" class="headerlink" title="扩展注解的支持"></a>扩展注解的支持</h3><p>Java 8扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。下面演示几个例子：</p>
<pre><code class="lang-java">package com.javacodegeeks.java8.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.ArrayList;
import java.util.Collection;

public class Annotations {
    @Retention( RetentionPolicy.RUNTIME )
    @Target( { ElementType.TYPE_USE, ElementType.TYPE_PARAMETER } )
    public @interface NonEmpty {
    }

    public static class Holder&lt; @NonEmpty T &gt; extends @NonEmpty Object {
        public void method() throws @NonEmpty Exception {
        }
    }

    @SuppressWarnings( &quot;unused&quot; )
    public static void main(String[] args) {
        final Holder&lt; String &gt; holder = new @NonEmpty Holder&lt; String &gt;();
        @NonEmpty Collection&lt; @NonEmpty String &gt; strings = new ArrayList&lt;&gt;();
    }
}
</code></pre>
<p>ElementType.TYPE_USE和ElementType.TYPE_PARAMETER是两个新添加的用于描述适当的注解上下文的元素类型。在Java语言中，注解处理API也有小的改动来识别新增的类型注解。</p>
<h2 id="Java编译器的新特性"><a href="#Java编译器的新特性" class="headerlink" title="Java编译器的新特性"></a>Java编译器的新特性</h2><h3 id="参数名字"><a href="#参数名字" class="headerlink" title="参数名字"></a>参数名字</h3><p>很长一段时间里，Java程序员一直在发明不同的方式使得方法参数的名字能保留在Java字节码中，并且能够在运行时获取它们（比如，Paranamer类库）。最终，在Java 8中把这个强烈要求的功能添加到语言层面（通过反射API与Parameter.getName()方法）与字节码文件（通过新版的javac的–parameters选项）中。</p>
<pre><code class="lang-java">package com.javacodegeeks.java8.parameter.names;

import java.lang.reflect.Method;
import java.lang.reflect.Parameter;

public class ParameterNames {
    public static void main(String[] args) throws Exception {
        Method method = ParameterNames.class.getMethod( &quot;main&quot;, String[].class );
        for( final Parameter parameter: method.getParameters() ) {
            System.out.println( &quot;Parameter: &quot; + parameter.getName() );
        }
    }
}
</code></pre>
<p>如果不使用–parameters参数来编译这个类，然后运行这个类，会得到下面的输出：</p>
<pre><code class="lang-java">Parameter: arg0
</code></pre>
<p>如果使用–parameters参数来编译这个类，程序的结构会有所不同（参数的真实名字将会显示出来）：</p>
<pre><code class="lang-java">Parameter: args
</code></pre>
<p>对于有经验的Maven用户，通过maven-compiler-plugin的配置可以将-parameters参数添加到编译器中去。</p>
<pre><code class="lang-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1&lt;/version&gt;
    &lt;configuration&gt;
        &lt;compilerArgument&gt;-parameters&lt;/compilerArgument&gt;
        &lt;source&gt;1.8&lt;/source&gt;
        &lt;target&gt;1.8&lt;/target&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
`
</code></pre>
<p>针对Java 8最新发布的Eclipse Kepler SR2（请检查这里的下载说明）提供了非常实用的配置选项，可以通过下图的配置方式来控制编译器行为</p>
<blockquote>
<p>ps:原文链接已失效！在最新的eclipse mars 等后续版本，只要支持jdk8的版本中均有该选项了</p>
</blockquote>
<p><img src="/2016/10/08/java-8-features-tutorial/01.ECLIPSE-JAVA-COMPILER.png" alt=""></p>
<p>图1. 配置Eclipse工程使之支持Java 8编译器的新特性——parameters参数</p>
<p>此外，Parameter类有一个很方便的方法isNamePresent()来验证是否可以获取参数的名字。</p>
<h2 id="Java-类库的新特性"><a href="#Java-类库的新特性" class="headerlink" title="Java 类库的新特性"></a>Java 类库的新特性</h2><p>Java 8 通过增加大量新类，扩展已有类的功能的方式来改善对并发编程、函数式编程、日期/时间相关操作以及其他更多方面的支持。</p>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到<a href="https://github.com/google/guava" target="_blank" rel="external">Google Guava</a>的启发，Optional类已经成为Java 8类库的一部分。</p>
<p>Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。更多详情请参考<a href="http://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="external">官方文档</a>。</p>
<p>我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。</p>
<pre><code class="lang-java">Optional&lt; String &gt; fullName = Optional.ofNullable( null );
System.out.println( &quot;Full Name is set? &quot; + fullName.isPresent() );
System.out.println( &quot;Full Name: &quot; + fullName.orElseGet( () -&gt; &quot;[none]&quot; ) );
System.out.println( fullName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );
</code></pre>
<p>如果Optional类的实例为非空值的话，isPresent()返回true，否从返回false。为了防止Optional为空值，orElseGet()方法通过回调函数来产生一个默认值。map()函数对当前Optional的值进行转化，然后返回一个新的Optional实例。orElse()方法和orElseGet()方法类似，但是orElse接受一个默认值而不是一个回调函数。下面是这个程序的输出：</p>
<pre><code class="lang-java">Full Name is set? false
Full Name: [none]
Hey Stranger!
</code></pre>
<p>让我们来看看另一个例子：</p>
<pre><code class="lang-java">Optional&lt; String &gt; firstName = Optional.of( &quot;Tom&quot; );
System.out.println( &quot;First Name is set? &quot; + firstName.isPresent() );
System.out.println( &quot;First Name: &quot; + firstName.orElseGet( () -&gt; &quot;[none]&quot; ) );
System.out.println( firstName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );
System.out.println();
</code></pre>
<p>下面是程序的输出：</p>
<pre><code class="lang-java">First Name is set? true
First Name: Tom
Hey Tom!
</code></pre>
<p>更多详情请参考<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>最新添加的<a href="https://www.javacodegeeks.com/2014/05/the-effects-of-programming-with-java-8-streams-on-algorithm-performance.html" target="_blank" rel="external">Stream API(java.util.stream)</a>把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>Stream API极大简化了集合框架的处理（但它的处理的范围不仅仅限于集合框架的处理，这点后面我们会看到）。让我们以一个简单的Task类为例进行介绍：</p>
<pre><code class="lang-java">public class Streams  {
    private enum Status {
        OPEN, CLOSED
    };

    private static final class Task {
        private final Status status;
        private final Integer points;

        Task( final Status status, final Integer points ) {
            this.status = status;
            this.points = points;
        }

        public Integer getPoints() {
            return points;
        }

        public Status getStatus() {
            return status;
        }

        @Override
        public String toString() {
            return String.format( &quot;[%s, %d]&quot;, status, points );
        }
    }
}
</code></pre>
<p>Task类有一个分数的概念（或者说是伪复杂度），其次是还有一个值可以为OPEN或CLOSED的状态.让我们引入一个Task的小集合作为演示例子：</p>
<pre><code class="lang-java">final Collection&lt; Task &gt; tasks = Arrays.asList(
    new Task( Status.OPEN, 5 ),
    new Task( Status.OPEN, 13 ),
    new Task( Status.CLOSED, 8 )
);
</code></pre>
<p>我们下面要讨论的第一个问题是所有状态为OPEN的任务一共有多少分数？在Java 8以前，一般的解决方式用foreach循环，但是在Java 8里面我们可以使用stream：一串支持连续、并行聚集操作的元素。</p>
<pre><code class="lang-java">// Calculate total points of all active tasks using sum()
final long totalPointsOfOpenTasks = tasks
    .stream()
    .filter( task -&gt; task.getStatus() == Status.OPEN )
    .mapToInt( Task::getPoints )
    .sum();

System.out.println( &quot;Total points: &quot; + totalPointsOfOpenTasks );
</code></pre>
<p>程序在控制台上的输出如下：</p>
<pre><code class="lang-bash">Total points: 18
</code></pre>
<p>这里有几个注意事项:</p>
<ol>
<li>task集合被转换化为其相应的stream表示</li>
<li>filter操作过滤掉状态为CLOSED的task。</li>
<li>mapToInt操作通过Task::getPoints这种方式调用每个task实例的getPoints方法把Task的stream转化为Integer的stream。</li>
<li>用sum函数把所有的分数加起来，得到最终的结果。</li>
</ol>
<p>在继续讲解下面的例子之前，关于stream有一些需要注意的地方（<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps" target="_blank" rel="external">详情</a>）.stream操作被分成了中间操作与最终操作这两种。</p>
<p>中间操作返回一个新的stream对象。中间操作总是采用惰性求值方式，运行一个像filter这样的中间操作实际上没有进行任何过滤，相反它在遍历元素时会产生了一个新的stream对象，这个新的stream对象包含原始stream<br>中符合给定谓词的所有元素。</p>
<p>像forEach、sum这样的最终操作可能直接遍历stream，产生一个结果或副作用。当最终操作执行结束之后，stream管道被认为已经被消耗了，没有可能再被使用了。在大多数情况下，最终操作都是采用及早求值方式，及早完成底层数据源的遍历。</p>
<p>stream另一个有价值的地方是能够原生支持并行处理。让我们来看看这个算task分数和的例子。</p>
<pre><code class="lang-java">// Calculate total points of all tasks
final double totalPoints = tasks
   .stream()
   .parallel()
   .map( task -&gt; task.getPoints() ) // or map( Task::getPoints )
   .reduce( 0, Integer::sum );

System.out.println( &quot;Total points (all tasks): &quot; + totalPoints );
</code></pre>
<p>这个例子和第一个例子很相似，但这个例子的不同之处在于这个程序是并行运行的，其次使用reduce方法来算最终的结果。<br>下面是这个例子在控制台的输出：</p>
<pre><code class="lang-bash">Total points (all tasks): 26.0
</code></pre>
<p>经常会有这个一个需求：我们需要按照某种准则来对集合中的元素进行分组。Stream也可以处理这样的需求，下面是一个例子：</p>
<pre><code class="lang-java">// Group tasks by their status
final Map&lt; Status, List&lt; Task &gt; &gt; map = tasks
    .stream()
    .collect( Collectors.groupingBy( Task::getStatus ) );
System.out.println( map );
</code></pre>
<p>这个例子的控制台输出如下：</p>
<pre><code class="lang-bash">{CLOSED=[[CLOSED, 8]], OPEN=[[OPEN, 5], [OPEN, 13]]}
</code></pre>
<p>让我们来计算整个集合中每个task分数（或权重）的平均值来结束task的例子。</p>
<pre><code class="lang-java">// Calculate the weight of each tasks (as percent of total points)
final Collection&lt; String &gt; result = tasks
    .stream()                                        // Stream&lt; String &gt;
    .mapToInt( Task::getPoints )                     // IntStream
    .asLongStream()                                  // LongStream
    .mapToDouble( points -&gt; points / totalPoints )   // DoubleStream
    .boxed()                                         // Stream&lt; Double &gt;
    .mapToLong( weigth -&gt; ( long )( weigth * 100 ) ) // LongStream
    .mapToObj( percentage -&gt; percentage + &quot;%&quot; )      // Stream&lt; String&gt;
    .collect( Collectors.toList() );                 // List&lt; String &gt;

System.out.println( result );
</code></pre>
<p>下面是这个例子的控制台输出：</p>
<pre><code class="lang-bash">[19%, 50%, 30%]
</code></pre>
<p>最后，就像前面提到的，Stream API不仅仅处理Java集合框架。像从文本文件中逐行读取数据这样典型的I/O操作也很适合用Stream API来处理。下面用一个例子来应证这一点。</p>
<pre><code class="lang-java">final Path path = new File( filename ).toPath();
try( Stream&lt; String &gt; lines = Files.lines( path, StandardCharsets.UTF_8 ) ) {
    lines.onClose( () -&gt; System.out.println(&quot;Done!&quot;) ).forEach( System.out::println );
}
</code></pre>
<p>对一个stream对象调用onClose方法会返回一个在原有功能基础上新增了关闭功能的stream对象，当对stream对象调用close()方法时，与关闭相关的处理器就会执行。</p>
<p>Stream API、Lambda表达式与方法引用在接口默认方法与静态方法的配合下是Java 8对现代软件开发范式的回应。更多详情请参考<a href="http://docs.oracle.com/javase/tutorial/collections/streams/index.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="Date-Time-API-JSR-310"><a href="#Date-Time-API-JSR-310" class="headerlink" title="Date/Time API (JSR 310)"></a>Date/Time API (JSR 310)</h3><p>Java 8通过发布新的<a href="https://jcp.org/en/jsr/detail?id=310" target="_blank" rel="external">Date-Time API (JSR 310)</a>来进一步加强对日期与时间的处理。对日期与时间的操作一直是Java程序员最痛苦的地方之一。标准的 java.util.Date以及后来的java.util.Calendar一点没有改善这种情况（可以这么说，它们一定程度上更加复杂）。</p>
<p>这种情况直接导致了Joda-Time——一个可替换标准日期/时间处理且功能非常强大的Java API的诞生。Java 8新的Date-Time API (JSR 310)在很大程度上受到Joda-Time的影响，并且吸取了其精髓。新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。在设计新版API时，十分注重与旧版API的兼容性：不允许有任何的改变（从java.util.Calendar中得到的深刻教训）。如果需要修改，会返回这个类的一个新实例。</p>
<p>让我们用例子来看一下新版API主要类的使用方法。第一个是Clock类，它通过指定一个时区，然后就可以获取到当前的时刻，日期与时间。Clock可以替换System.currentTimeMillis()与TimeZone.getDefault()。</p>
<pre><code class="lang-java">// Get the system clock as UTC offset
final Clock clock = Clock.systemUTC();
System.out.println( clock.instant() );
System.out.println( clock.millis() );
</code></pre>
<p>下面是程序在控制台上的输出：</p>
<pre><code class="lang-bash">2014-04-12T15:19:29.282Z
1397315969360
</code></pre>
<p>我们需要关注的其他类是LocaleDate与LocalTime。LocaleDate只持有ISO-8601格式且无时区信息的日期部分。相应的，LocaleTime只持有ISO-8601格式且无时区信息的时间部分。LocaleDate与LocalTime都可以从Clock中得到。</p>
<pre><code class="lang-java">// Get the local date and local time
final LocalDate date = LocalDate.now();
final LocalDate dateFromClock = LocalDate.now( clock );

System.out.println( date );
System.out.println( dateFromClock );

// Get the local date and local time
final LocalTime time = LocalTime.now();
final LocalTime timeFromClock = LocalTime.now( clock );

System.out.println( time );
System.out.println( timeFromClock );
</code></pre>
<p>下面是程序在控制台上的输出:</p>
<pre><code class="lang-bash">2014-04-12
2014-04-12
11:25:54.568
15:25:54.568
</code></pre>
<p>LocaleDateTime把LocaleDate与LocaleTime的功能合并起来，它持有的是ISO-8601格式无时区信息的日期与时间。下面是一个快速入门的例子。</p>
<pre><code class="lang-java">// Get the local date/time
final LocalDateTime datetime = LocalDateTime.now();
final LocalDateTime datetimeFromClock = LocalDateTime.now( clock );

System.out.println( datetime );
System.out.println( datetimeFromClock );
</code></pre>
<p>下面是程序在控制台上的输出：</p>
<pre><code class="lang-bash">2014-04-12T11:37:52.309
2014-04-12T15:37:52.309
</code></pre>
<p>如果你需要特定时区的日期/时间，那么ZonedDateTime是你的选择。它持有ISO-8601格式具具有时区信息的日期与时间。下面是一些不同时区的例子：</p>
<pre><code class="lang-java">// Get the zoned date/time
final ZonedDateTime zonedDatetime = ZonedDateTime.now();
final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now( clock );
final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now( ZoneId.of( &quot;America/Los_Angeles&quot; ) );

System.out.println( zonedDatetime );
System.out.println( zonedDatetimeFromClock );
System.out.println( zonedDatetimeFromZone );
</code></pre>
<p>下面是程序在控制台上的输出：</p>
<pre><code class="lang-bash">2014-04-12T11:47:01.017-04:00[America/New_York]
2014-04-12T15:47:01.017Z
2014-04-12T08:47:01.017-07:00[America/Los_Angeles]
</code></pre>
<p>最后，让我们看一下Duration类：在秒与纳秒级别上的一段时间。Duration使计算两个日期间的不同变的十分简单。下面让我们看一个这方面的例子。</p>
<pre><code class="lang-java">// Get duration between two dates
final LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );
final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );

final Duration duration = Duration.between( from, to );
System.out.println( &quot;Duration in days: &quot; + duration.toDays() );
System.out.println( &quot;Duration in hours: &quot; + duration.toHours() );
</code></pre>
<p>上面的例子计算了两个日期2014年4月16号与2014年4月16号之间的过程。下面是程序在控制台上的输出：</p>
<pre><code class="lang-bash">Duration in days: 365
Duration in hours: 8783
</code></pre>
<p>对Java 8在日期/时间API的改进整体印象是非常非常好的。一部分原因是因为它建立在“久战杀场”的Joda-Time基础上，另一方面是因为用来大量的时间来设计它，并且这次程序员的声音得到了认可。更多详情请参考<a href="http://docs.oracle.com/javase/tutorial/datetime/index.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="JavaScript引擎Nashorn"><a href="#JavaScript引擎Nashorn" class="headerlink" title="JavaScript引擎Nashorn"></a>JavaScript引擎Nashorn</h3><p>Nashorn，一个新的JavaScript引擎随着Java 8一起公诸于世，它允许在JVM上开发运行某些JavaScript应用。Nashorn就是javax.script.ScriptEngine的另一种实现，并且它们俩遵循相同的规则，允许Java与JavaScript相互调用。下面看一个例子：</p>
<pre><code class="lang-java">ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName( &quot;JavaScript&quot; );

System.out.println( engine.getClass().getName() );
System.out.println( &quot;Result:&quot; + engine.eval( &quot;function f() { return 1; }; f() + 1;&quot; ) );
</code></pre>
<p>下面是程序在控制台上的输出：</p>
<pre><code class="lang-bash">jdk.nashorn.api.scripting.NashornScriptEngine
Result: 2
</code></pre>
<p>我们在后面的Java新工具章节会再次谈到Nashorn。</p>
<h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>在Java 8中，Base64编码已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子：</p>
<pre><code class="lang-java">package com.javacodegeeks.java8.base64;

import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class Base64s {
    public static void main(String[] args) {
        final String text = &quot;Base64 finally in Java 8!&quot;;

        final String encoded = Base64
            .getEncoder()
            .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );
        System.out.println( encoded );

        final String decoded = new String(
            Base64.getDecoder().decode( encoded ),
            StandardCharsets.UTF_8 );
        System.out.println( decoded );
    }
}
</code></pre>
<p>程序在控制台上输出了编码后的字符与解码后的字符：</p>
<pre><code class="lang-bash">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==
Base64 finally in Java 8!
</code></pre>
<p>Base64类同时还提供了对URL、MIME友好的编码器与解码器（Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder()）</p>
<h3 id="并行（parallel）数组"><a href="#并行（parallel）数组" class="headerlink" title="并行（parallel）数组"></a>并行（parallel）数组</h3><p>Java 8增加了大量的新方法来对数组进行并行处理。可以说，最重要的是parallelSort()方法，因为它可以在多核机器上极大提高数组排序的速度。下面的例子展示了新方法（parallelXxx）的使用。</p>
<pre><code class="lang-java">package com.javacodegeeks.java8.parallel.arrays;

import java.util.Arrays;
import java.util.concurrent.ThreadLocalRandom;

public class ParallelArrays {
    public static void main( String[] args ) {
        long[] arrayOfLong = new long [ 20000 ];

        Arrays.parallelSetAll( arrayOfLong,
            index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) );
        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(
            i -&gt; System.out.print( i + &quot; &quot; ) );
        System.out.println();

        Arrays.parallelSort( arrayOfLong );
        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(
            i -&gt; System.out.print( i + &quot; &quot; ) );
        System.out.println();
    }
}
</code></pre>
<p>上面的代码片段使用了parallelSetAll()方法来对一个有20000个元素的数组进行随机赋值。然后，调用parallelSort方法。这个程序首先打印出前10个元素的值，之后对整个数组排序。这个程序在控制台上的输出如下（请注意数组元素是随机生产的）：</p>
<pre><code class="lang-bash">Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378
Sorted: 39 220 263 268 325 607 655 678 723 793
</code></pre>
<h3 id="并发（Concurrency）"><a href="#并发（Concurrency）" class="headerlink" title="并发（Concurrency）"></a>并发（Concurrency）</h3><p>在新增Stream机制与lambda的基础之上，在java.util.concurrent.ConcurrentHashMap中加入了一些新方法来支持聚集操作。同时也在java.util.concurrent.ForkJoinPool类中加入了一些新方法来支持共有资源池（common pool）（请查看我们关于Java 并发的免费课程）。</p>
<p>新增的java.util.concurrent.locks.StampedLock类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的java.util.concurrent.locks.ReadWriteLock类的替代者）。</p>
<p>在java.util.concurrent.atomic包中还增加了下面这些类：</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder</li>
</ul>
<h2 id="新的Java工具"><a href="#新的Java工具" class="headerlink" title="新的Java工具"></a>新的Java工具</h2><p>Java 8也带来了一些新的命令行工具。在这节里我们将会介绍它们中最有趣的部分。</p>
<h3 id="Nashorn引擎-jjs"><a href="#Nashorn引擎-jjs" class="headerlink" title="Nashorn引擎: jjs"></a>Nashorn引擎: jjs</h3><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。例如，我们创建一个具有如下内容的func.js文件：</p>
<pre><code class="lang-javascript">function f() {
     return 1;
};

print( f() + 1 );
</code></pre>
<p>我们可以把这个文件作为参数传递给jjs使得这个文件可以在命令行中执行：</p>
<pre><code class="lang-bash">jjs func.js
</code></pre>
<p>下面是程序在控制台上的输出：</p>
<pre><code class="lang-bash">2
</code></pre>
<p>更多详情请参考<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jjs.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="类依赖分析器jdeps"><a href="#类依赖分析器jdeps" class="headerlink" title="类依赖分析器jdeps"></a>类依赖分析器jdeps</h3><p>jdeps是一个很有用的命令行工具。它可以显示Java类的包级别或类级别的依赖。它接受一个.class文件，一个目录，或者一个jar文件作为输入。jdeps默认把结果输出到系统输出（控制台）上。</p>
<p>下面我们查看现阶段较流行的Spring框架类库的依赖报告，为了简化这个例子，我们只分析一个jar文件：org.springframework.core-3.0.5.RELEASE.jar</p>
<pre><code class="lang-bash">jdeps org.springframework.core-3.0.5.RELEASE.jar
</code></pre>
<p>这个命令输出的内容很多，所以这里我们只选取一小部分。依赖信息按照包名进行分组。如果依赖不在classpath中，那么就会显示not found。</p>
<pre><code class="lang-bash">org.springframework.core-3.0.5.RELEASE.jar -&gt; C:\Program Files\Java\jdk1.8.0\jre\lib\rt.jar
   org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar)
      -&gt; java.io
      -&gt; java.lang
      -&gt; java.lang.annotation
      -&gt; java.lang.ref
      -&gt; java.lang.reflect
      -&gt; java.util
      -&gt; java.util.concurrent
      -&gt; org.apache.commons.logging                         not found
      -&gt; org.springframework.asm                            not found
      -&gt; org.springframework.asm.commons                    not found
   org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar)
      -&gt; java.lang
      -&gt; java.lang.annotation
      -&gt; java.lang.reflect
      -&gt; java.util
</code></pre>
<p>更多详情请参考<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jdeps.html" target="_blank" rel="external">官方文档</a></p>
<h2 id="Java虚拟机（JVM）的新特性"><a href="#Java虚拟机（JVM）的新特性" class="headerlink" title="Java虚拟机（JVM）的新特性"></a>Java虚拟机（JVM）的新特性</h2><p>PermGen空间被移除了，取而代之的是<a href="https://www.javacodegeeks.com/2013/02/java-8-from-permgen-to-metaspace.html" target="_blank" rel="external">Metaspace（JEP 122）</a>。JVM选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多展望：Java 8通过发布一些可以增加程序员生产力的特性来推进这个伟大的平台的进步。现在把生产环境迁移到Java 8还为时尚早，但是在接下来的几个月里，它会被大众慢慢的接受。毫无疑问，现在是时候让你的代码与Java 8兼容，并且在Java 8足够安全稳定的时候迁移到Java 8。</p>
<p>作为社区对Java 8的认可，最近Pivotal发布了可在生产环境下支持Java 8的<a href="https://spring.io/blog/2014/03/27/spring-framework-4-0-3-released-with-java-8-support-now-production-ready" target="_blank" rel="external">Spring Framework 4.0.3</a>。</p>
<p>我们欢迎你对Java 8中激动人心的特性进行评论！</p>
<h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><p>下面一些文章从不同层面上深度讨论了Java 8的特性：</p>
<ul>
<li><a href="https://examples.javacodegeeks.com/?s=java+8" target="_blank" rel="external">Java 8 Tutorials on JCG Examples</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="external">What’s New in JDK 8</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/" target="_blank" rel="external">The Java Tutorials:</a></li>
<li><a href="http://blog.arungupta.me/2014/03/wildfly8-jdk8-netbeans8-javaee7-excellent-combo-enterprise-java/" target="_blank" rel="external">WildFly 8, JDK 8, NetBeans 8, Java EE 7</a></li>
<li><a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">Java 8 Tutorial</a></li>
<li><a href="http://marxsoftware.blogspot.ca/2014/03/jdeps.html" target="_blank" rel="external">JDK 8 Command-line Static Dependency Checker</a></li>
<li><a href="http://marxsoftware.blogspot.ca/2014/03/illuminating-javadoc-of-jdk-8.html" target="_blank" rel="external">The Illuminating Javadoc of JDK 8</a></li>
<li><a href="http://blog.jooq.org/2014/04/04/java-8-friday-the-dark-side-of-java-8/" target="_blank" rel="external">The Dark Side of Java 8</a></li>
<li><a href="http://www.baeldung.com/java8" target="_blank" rel="external">Java 8</a></li>
<li><a href="http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html" target="_blank" rel="external">Oracle Nashorn. A Next-Generation JavaScript Engine for the JVM</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自importnew本文链接地址: &lt;a href=&quot;http://www.importnew.com/11908.html&quot;&gt;Java 8新特性终极指南&lt;/a&gt;&lt;br&gt;本文为译文，推荐看原文：&lt;a href=&quot;https://www.javacodegeeks.com/2014/05/java-8-features-tutorial.html&quot;&gt;Java 8 Features Tutorial – The ULTIMATE Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ps:原文可能要翻墙.&lt;/p&gt;
&lt;p&gt;JDK8其实已问世很久了。JDK9也即将到来，截止该文章发布时，JDK8也还没有在大部分的环境中大量使用。在本人当前所在公司,JDK7还是主流，部分老框架项目还在用着JDK6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;毫无疑问，Java 8发行版是自Java 5（发行于2004，已经过了相当一段时间了）以来最具革命性的版本。Java 8 为Java语言、编译器、类库、开发工具与JVM（Java虚拟机）带来了大量新特性。在这篇教程中，我们将一一探索这些变化，并用真实的例子说明它们适用的场景。&lt;/p&gt;
&lt;p&gt;这篇教程由以下几部分组成，它们分别涉及到Java平台某一特定方面的内容：&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="Java" scheme="https://www.deleiguo.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM实用参数（一）JVM类型以及编译器模式</title>
    <link href="https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-1-jvm-types-and-compiler-modes-2/"/>
    <id>https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-1-jvm-types-and-compiler-modes-2/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2016-12-08T10:21:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自并发编程网 – ifeve.com本文链接地址: <a href="http://ifeve.com/useful-jvm-flags-part-1-jvm-types-and-compiler-modes-2/" target="_blank" rel="external">JVM实用参数（一）JVM类型以及编译器模式</a><br>本文是<a href="http://ifeve.com" target="_blank" rel="external">并发编程网</a>经原国外blog作者授权的中文译文</p>
</blockquote>
<p>原文地址:<a href="https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-1-jvm-types-and-compiler-modes/" target="_blank" rel="external">blog.codecentric.de</a></p>
<p><strong>译者：</strong> 赵峰，iDestiny<br><strong>校对：</strong> 郭蕾</p>
<p>现在的JVM运行Java程序（和其它的兼容性语言）时在高效性和稳定性方面做的非常出色。自适应内存管理、垃圾收集、及时编译、动态类加载、锁优化——这里仅仅列举了某些场景下会发生的神奇的事情，但他们几乎不会直接与普通的程序员相关。在运行时，JVM会不断的计算并优化应用或者应用的某些部分。</p>
<p>虽然有了这种程度的自动化（或者说有这么多自动化），但是JVM仍然提供了足够多的外部监控和手动调优工具。在有错误或低性能的情况下，JVM必须能够让专家调试。顺便说一句，除了这些隐藏在引擎中的神奇功能，允许大范围的手动调优也是现代JVM的优势之一。有趣的是，一些命令行参数可以在JVM启动时传入到JVM中。一些JVM提供了几百个这样的参数，所以如果没有这方面的知识很容易迷失。这系列博客的目标是着重讲解日常相关的一些参数以及他们的适用场合。我们将专注于Java6的Sun/Oracle HotSpot JVM，大多数情况下，这些参数也会适用于其他一些流行的JVM里。</p>
<p><strong>-server and -client</strong></p>
<a id="more"></a>
<p>有两种类型的 HotSpot JVM，即”server”和”client”。服务端的VM中的默认为堆提供了一个更大的空间以及一个并行的垃圾收集器，并且在运行时可以更大程度地优化代码。客户端的VM更加保守一些（校对注：这里作者指客户端虚拟机有较小的默认堆大小），这样可以缩短JVM的启动时间和占用更少的内存。有一个叫”JVM功效学”的概念，它会在JVM启动的时候根据可用的硬件和操作系统来自动的选择JVM的类型。具体的标准可以在这里找到。从标准表中，我们可以看到客户端的VM只在32位系统中可用。</p>
<p>如果我们不喜欢预选（校对注：指JVM自动选择的JVM类型）的JVM，我们可以使用-server和-client参数来设置使用服务端或客户端的VM。虽然当初服务端VM的目标是长时间运行的服务进程，但是现在看来，在运行独立应用程序时它比客户端VM有更出色的性能。当应用的性能非常重要时，我推荐使用-server参数来选择服务端VM。一个常见的问题：在一个32位的系统上，HotSpot JDK可以运行服务端VM，但是32位的JRE只能运行客户端VM。</p>
<p><strong>-version and -showversion</strong></p>
<p>当我们调用“java”命令时，我们如何才能知道我们安装的是哪个版本的Java和JVM类型呢？在同一个系统中安装多个Java，如果不注意的话有运行错误JVM的风险。在不同的Linux版本上预装JVM这方面，我承认现在已经变的比以前好很多了。幸运的是，我们现在可以使用-version参数，它可以打印出正在使用的JVM的信息。例如：</p>
<pre><code class="lang-bash">$ java -version
java version &quot;1.6.0_24&quot;
Java(TM) SE Runtime Environment (build 1.6.0_24-b07)
Java HotSpot(TM) Client VM (build 19.1-b02, mixed mode, sharing)
</code></pre>
<p>输出显示的是Java版本号(1.6.0_24)和JRE确切的build号(1.6.0_24-b07)。我们也可以看到JVM的名字(HotSpot)、类型(client)和build ID（19.1-b02) ）。除此之外，我们还知道JVM以混合模式(mixed mode)在运行，这是HotSpot默认的运行模式，意味着JVM在运行时可以动态的把字节码编译为本地代码。我们也可以看到类数据共享（class data sharing）是开启的，类数据共享（class data sharing）是一种在只读缓存（在jsa文件中，”Java Shared Archive”）中存储JRE的系统类，被所有Java进程的类加载器用来当做共享资源。类数据共享(Class data sharing)可能在经常从jar文档中读所有的类数据的情况下显示出性能优势。</p>
<p>-version参数在打印完上述信息后立即终止JVM。还有一个类似的参数-showversion可以用来输出相同的信息，但是-showversion紧接着会处理并执行Java程序。因此，-showversion对几乎所有Java应用的命令行都是一个有效的补充。你永远不知道你什么时候，突然需要了解一个特定的Java应用（崩溃时）使用的JVM的一些信息。在启动时添加-showversion，我们就能保证当我们需要时可以得到这些信息。</p>
<p><strong>-Xint, -Xcomp, 和 -Xmixed</strong></p>
<p>-Xint和-Xcomp参数和我们的日常工作不是很相关，但是我非常有兴趣通过它来了解下JVM。在解释模式(interpreted mode)下，-Xint标记会强制JVM执行所有的字节码，当然这会降低运行速度，通常低10倍或更多。-Xcomp参数与它（-Xint）正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。这听起来不错，因为这完全绕开了缓慢的解释器。然而，很多应用在使用-Xcomp也会有一些性能损失，当然这比使用-Xint损失的少，原因是-xcomp没有让JVM启用JIT编译器的全部功能。JIT编译器在运行时创建方法使用文件，然后一步一步的优化每一个方法，有时候会主动的优化应用的行为。这些优化技术，比如，积极的分支预测（optimistic branch prediction），如果不先分析应用就不能有效的使用。另一方面方法只有证明它们与此相关时才会被编译，也就是，在应用中构建某种热点。被调用很少（甚至只有一次）的方法在解释模式下会继续执行，从而减少编译和优化成本。</p>
<p>注意混合模式也有他自己的参数，-Xmixed。最新版本的HotSpot的默认模式是混合模式，所以我们不需要特别指定这个标记。我们来用对象填充HashMap然后检索它的结果做一个简单的用例。每一个例子，它的运行时间都是很多次运行的平均时间。</p>
<pre><code class="lang-bash">$ java -server -showversion Benchmark
java version &quot;1.6.0_24&quot;
Java(TM) SE Runtime Environment (build 1.6.0_24-b07)
Java HotSpot(TM) Server VM (build 19.1-b02, mixed mode)

Average time: 0.856449 seconds
</code></pre>
<pre><code class="lang-bash">$ java -server -showversion -Xint Benchmark
java version &quot;1.6.0_24&quot;
Java(TM) SE Runtime Environment (build 1.6.0_24-b07)
Java HotSpot(TM) Server VM (build 19.1-b02, interpreted mode)

Average time: 7.622285 seconds
</code></pre>
<p>当然也有很多使-Xcomp表现很好的例子。特别是运行时间长的应用，我强烈建议大家使用JVM的默认设置,让JIT编译器充分发挥其动态潜力，毕竟JIT编译器是组成JVM最重要的组件之一。事实上，正是因为JVM在这方面的进展才让Java不再那么慢。<br>JVM类型以及编译器模式</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自并发编程网 – ifeve.com本文链接地址: &lt;a href=&quot;http://ifeve.com/useful-jvm-flags-part-1-jvm-types-and-compiler-modes-2/&quot;&gt;JVM实用参数（一）JVM类型以及编译器模式&lt;/a&gt;&lt;br&gt;本文是&lt;a href=&quot;http://ifeve.com&quot;&gt;并发编程网&lt;/a&gt;经原国外blog作者授权的中文译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-1-jvm-types-and-compiler-modes/&quot;&gt;blog.codecentric.de&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者：&lt;/strong&gt; 赵峰，iDestiny&lt;br&gt;&lt;strong&gt;校对：&lt;/strong&gt; 郭蕾&lt;/p&gt;
&lt;p&gt;现在的JVM运行Java程序（和其它的兼容性语言）时在高效性和稳定性方面做的非常出色。自适应内存管理、垃圾收集、及时编译、动态类加载、锁优化——这里仅仅列举了某些场景下会发生的神奇的事情，但他们几乎不会直接与普通的程序员相关。在运行时，JVM会不断的计算并优化应用或者应用的某些部分。&lt;/p&gt;
&lt;p&gt;虽然有了这种程度的自动化（或者说有这么多自动化），但是JVM仍然提供了足够多的外部监控和手动调优工具。在有错误或低性能的情况下，JVM必须能够让专家调试。顺便说一句，除了这些隐藏在引擎中的神奇功能，允许大范围的手动调优也是现代JVM的优势之一。有趣的是，一些命令行参数可以在JVM启动时传入到JVM中。一些JVM提供了几百个这样的参数，所以如果没有这方面的知识很容易迷失。这系列博客的目标是着重讲解日常相关的一些参数以及他们的适用场合。我们将专注于Java6的Sun/Oracle HotSpot JVM，大多数情况下，这些参数也会适用于其他一些流行的JVM里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-server and -client&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM实用参数（二）参数分类和即时（JIT）编译器诊断</title>
    <link href="https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-2-flag/"/>
    <id>https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-2-flag/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2016-12-08T10:21:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自并发编程网 – ifeve.com本文链接地址: <a href="http://ifeve.com/useful-jvm-flags-part-2-flag/" target="_blank" rel="external">JVM实用参数（二）参数分类和即时（JIT）编译器诊断</a><br>本文是<a href="http://ifeve.com" target="_blank" rel="external">并发编程网</a>经原国外blog作者授权的中文译文</p>
</blockquote>
<p>原文地址:<a href="https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-2-flag-categories-and-jit-compiler-diagnostics" target="_blank" rel="external">blog.codecentric.de</a></p>
<p><strong>译者：</strong> 赵峰，iDestiny<br><strong>校对：</strong> 许巧辉</p>
<p>在这个系列的第二部分，我来介绍一下HotSpot JVM提供的不同类别的参数。我同样会讨论一些关于JIT编译器诊断的有趣参数。</p>
<h2 id="JVM-参数分类"><a href="#JVM-参数分类" class="headerlink" title="JVM 参数分类"></a>JVM 参数分类</h2><p>HotSpot JVM 提供了三类参数。第一类包括了标准参数。顾名思义，标准参数中包括功能和输出的参数都是很稳定的，很可能在将来的JVM版本中不会改变。你可以用java命令（或者是用 java -help）检索出所有标准参数。我们在第一部分中已经见到过一些标准参数，例如：-server。</p>
<p>第二类是X参数，非标准化的参数在将来的版本中可能会改变。所有的这类参数都以-X开始，并且可以用java -X来检索。注意，不能保证所有参数都可以被检索出来，其中就没有-Xcomp。</p>
<p>第三类是包含XX参数（到目前为止最多的），它们同样不是标准的，甚至很长一段时间内不被列出来（最近，这种情况有改变 ，我们将在本系列的第三部分中讨论它们）。然而，在实际情况中X参数和XX参数并没有什么不同。X参数的功能是十分稳定的，然而很多XX参数仍在实验当中（主要是JVM的开发者用于debugging和调优JVM自身的实现）。值的一读的介绍非标准参数的文档 <a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="external">HotSpot JVM documentation</a>，其中明确的指出XX参数不应该在不了解的情况下使用。这是真的，并且我认为这个建议同样适用于X参数（同样一些标准参数也是）。不管类别是什么，在使用参数之前应该先了解它可能产生的影响。</p>
<p>用一句话来说明XX参数的语法。所有的XX参数都以”-XX:”开始，但是随后的语法不同，取决于参数的类型。</p>
<p>对于布尔类型的参数，我们有”+”或”-“，然后才设置JVM选项的实际名称。例如，-XX:+<name>用于激活<name>选项，而-XX:-<name>用于注销选项。<br>对于需要非布尔值的参数，如string或者integer，我们先写参数的名称，后面加上”=”，最后赋值。例如，  -XX:<name>=<value>给<name>赋值<value>。<br>现在让我们来看看JIT编译方面的一些XX参数。</value></name></value></name></name></name></name></p>
<p><strong>-XX:+PrintCompilation and -XX:+CITime</strong></p>
<a id="more"></a>
<p>当一个Java应用运行时，非常容易查看JIT编译工作。通过设置-XX:+PrintCompilation，我们可以简单的输出一些关于从字节码转化成本地代码的编译过程。我们来看一个服务端VM运行的例子：</p>
<pre><code class="lang-bash">$ java -server -XX:+PrintCompilation Benchmark
  1       java.lang.String::hashCode (64 bytes)
  2       java.lang.AbstractStringBuilder::stringSizeOfInt (21 bytes)
  3       java.lang.Integer::getChars (131 bytes)
  4       java.lang.Object::&lt;init&gt; (1 bytes)
---   n   java.lang.System::arraycopy (static)
  5       java.util.HashMap::indexFor (6 bytes)
  6       java.lang.Math::min (11 bytes)
  7       java.lang.String::getChars (66 bytes)
  8       java.lang.AbstractStringBuilder::append (60 bytes)
  9       java.lang.String::&lt;init&gt; (72 bytes)
 10       java.util.Arrays::copyOfRange (63 bytes)
 11       java.lang.StringBuilder::append (8 bytes)
 12       java.lang.AbstractStringBuilder::&lt;init&gt; (12 bytes)
 13       java.lang.StringBuilder::toString (17 bytes)
 14       java.lang.StringBuilder::&lt;init&gt; (18 bytes)
 15       java.lang.StringBuilder::append (8 bytes)
[...]
 29       java.util.regex.Matcher::reset (83 bytes)
</code></pre>
<p>每当一个方法被编译，就输出一行-XX:+PrintCompilation。每行都包含顺序号（唯一的编译任务ID）和已编译方法的名称和大小。因此，顺序号1，代表编译String类中的hashCode方法到原生代码的信息。根据方法的类型和编译任务打印额外的信息。例如，本地的包装方法前方会有”n”参数，像上面的System::arraycopy一样。注意这样的方法不会包含顺序号和方法占用的大小，因为它不需要编译为本地代码。同样可以看到被重复编译的方法，例如StringBuilder::append顺序号为11和15。输出在顺序号29时停止 ，这表明在这个Java应用运行时总共需要编译29个方法。</p>
<p>没有官方的文档关于-XX:+PrintCompilation，但是<a href="https://gist.github.com/rednaxelafx/1165804#file_notes.md" target="_blank" rel="external">这个描述</a>是对于此参数比较好的。我推荐更深入学习一下。</p>
<p>JIT编译器输出帮助我们理解客户端VM与服务端VM的一些区别。用服务端VM，我们的应用例子输出了29行，同样用客户端VM，我们会得到55行。这看起来可能很怪，因为服务端VM应该比客户端VM做了”更多”的编译。然而，由于它们各自的默认设置，服务端VM在判断方法是不是热点和需不需要编译时比客户端VM观察方法的时间更长。因此，在使用服务端VM时，一些潜在的方法会稍后编译就不奇怪了。</p>
<p>通过另外设置-XX:+CITime，我们可以在JVM关闭时得到各种编译的统计信息。让我们看一下一个特定部分的统计：</p>
<pre><code class="lang-bash">$ java -server -XX:+CITime Benchmark
[...]
Accumulated compiler times (for compiled methods only)
------------------------------------------------
  Total compilation time   :  0.178 s
    Standard compilation   :  0.129 s, Average : 0.004
    On stack replacement   :  0.049 s, Average : 0.024
[...]
</code></pre>
<p>总共用了0.178s（在29个编译任务上）。这些，”on stack replacement”占用了0.049s，即编译的方法目前在堆栈上用去的时间。这种技术并不是简单的实现性能显示，实际上它是非常重要的。没有”on stack replacement”，方法如果要执行很长时间（比如，它们包含了一个长时间运行的循环），它们运行时将不会被它们编译过的副本替换。</p>
<p>再一次，客户端VM与服务端VM的比较是非常有趣的。客户端VM相应的数据表明，即使有55个方法被编译了，但这些编译总共用了只有0.021s。服务端VM做的编译少但是用的时间却比客户端VM多。这个原因是，使用服务端VM在生成本地代码时执行了更多的优化。</p>
<p>在本系列的第一部分，我们已经学了-Xint和-Xcomp参数。结合使用-XX:+PrintCompilation和-XX:+CITime，在这两个情况下（校对者注，客户端VM与服务端VM），我们能对JIT编译器的行为有更好的了解。使用-Xint，-XX:+PrintCompilation在这两种情况下会产生0行输出。同样的，使用-XX:+CITime时，证实在编译上没有花费时间。现在换用-Xcomp，输出就完全不同了。在使用客户端VM时会产生726行输出，然后没有更多的，这是因为每个相关的方法都被编译了。使用服务端VM，我们甚至能得到993行输出，这告诉我们更积极的优化被执行了。同样，JVM 拆机(JVM teardown)时打印出的统计显示了两个VM的巨大不同。考虑服务端VM的运行：</p>
<pre><code class="lang-bash">$ java -server -Xcomp -XX:+CITime Benchmark
[...]
Accumulated compiler times (for compiled methods only)
------------------------------------------------
  Total compilation time   :  1.567 s
    Standard compilation   :  1.567 s, Average : 0.002
    On stack replacement   :  0.000 s, Average : -1.#IO
[...]
</code></pre>
<p>使用-Xcomp编译用了1.567s，这是使用默认设置（即，混合模式）的10倍。同样，应用程序的运行速度要比用混合模式的慢。相比较之下，客户端VM使用-Xcomp编译726个方法只用了0.208s，甚至低于使用-Xcomp的服务端VM。</p>
<p>补充一点，这里没有”on stack replacement”发生，因为每一个方法在第一次调用时被编译了。损坏的输出“Average: -1.#IO”（正确的是:0）再一次表明了，非标准化的输出参数不是非常可靠。</p>
<p><strong>-XX:+UnlockExperimentalVMOptions</strong></p>
<p>有些时候当设置一个特定的JVM参数时，JVM会在输出“Unrecognized VM option”后终止。如果发生了这种情况，你应该首先检查你是否输错了参数。然而，如果参数输入是正确的，并且JVM并不识别，你或许需要设置-XX:+UnlockExperimentalVMOptions 来解锁参数。我不是非常清楚这个安全机制的作用，但我猜想这个参数如果不正确使用可能会对JVM的稳定性有影响（例如，他们可能会过多的写入debug输出的一些日志文件）。</p>
<p>有一些参数只是在JVM开发时用，并不实际用于Java应用。如果一个参数不能被 -XX:+UnlockExperimentalVMOptions 开启，但是你真的需要使用它，此时你可以尝试使用debug版本的JVM。对于Java 6 HotSpot JVM你可以从这里找到。</p>
<p><strong>-XX:+LogCompilation and -XX:+PrintOptoAssembly</strong></p>
<p>如果你在一个场景中发现使用 -XX:+PrintCompilation，不能够给你足够详细的信息，你可以使用 -XX:+LogCompilation把扩展的编译输出写到“hotspot.log”文件中。除了编译方法的很多细节之外，你也可以看到编译器线程启动的任务。注意-XX:+LogCompilation 需要使用-XX:+UnlockExperimentalVMOptions来解锁。</p>
<p>JVM甚至允许我们看到从字节码编译生成到本地代码。使用-XX:+PrintOptoAssembly，由编译器线程生成的本地代码被输出并写到“hotspot.log”文件中。使用这个参数要求运行的服务端VM是debug版本。我们可以研究-XX:+PrintOptoAssembly的输出，以至于了解JVM实际执行什么样的优化，例如，关于死代码的消除。一个非常有趣的文章提供了一个例子。</p>
<p>关于XX参数的更多信息</p>
<p>如果这篇文章勾起了你的兴趣，你可以自己看一下HotSpot JVM的XX 参数。<a href="http://stas-blogspot.blogspot.de/2011/07/most-complete-list-of-xx-options-for.html" target="_blank" rel="external">这里</a>是一个很好的起点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自并发编程网 – ifeve.com本文链接地址: &lt;a href=&quot;http://ifeve.com/useful-jvm-flags-part-2-flag/&quot;&gt;JVM实用参数（二）参数分类和即时（JIT）编译器诊断&lt;/a&gt;&lt;br&gt;本文是&lt;a href=&quot;http://ifeve.com&quot;&gt;并发编程网&lt;/a&gt;经原国外blog作者授权的中文译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-2-flag-categories-and-jit-compiler-diagnostics&quot;&gt;blog.codecentric.de&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者：&lt;/strong&gt; 赵峰，iDestiny&lt;br&gt;&lt;strong&gt;校对：&lt;/strong&gt; 许巧辉&lt;/p&gt;
&lt;p&gt;在这个系列的第二部分，我来介绍一下HotSpot JVM提供的不同类别的参数。我同样会讨论一些关于JIT编译器诊断的有趣参数。&lt;/p&gt;
&lt;h2 id=&quot;JVM-参数分类&quot;&gt;&lt;a href=&quot;#JVM-参数分类&quot; class=&quot;headerlink&quot; title=&quot;JVM 参数分类&quot;&gt;&lt;/a&gt;JVM 参数分类&lt;/h2&gt;&lt;p&gt;HotSpot JVM 提供了三类参数。第一类包括了标准参数。顾名思义，标准参数中包括功能和输出的参数都是很稳定的，很可能在将来的JVM版本中不会改变。你可以用java命令（或者是用 java -help）检索出所有标准参数。我们在第一部分中已经见到过一些标准参数，例如：-server。&lt;/p&gt;
&lt;p&gt;第二类是X参数，非标准化的参数在将来的版本中可能会改变。所有的这类参数都以-X开始，并且可以用java -X来检索。注意，不能保证所有参数都可以被检索出来，其中就没有-Xcomp。&lt;/p&gt;
&lt;p&gt;第三类是包含XX参数（到目前为止最多的），它们同样不是标准的，甚至很长一段时间内不被列出来（最近，这种情况有改变 ，我们将在本系列的第三部分中讨论它们）。然而，在实际情况中X参数和XX参数并没有什么不同。X参数的功能是十分稳定的，然而很多XX参数仍在实验当中（主要是JVM的开发者用于debugging和调优JVM自身的实现）。值的一读的介绍非标准参数的文档 &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html&quot;&gt;HotSpot JVM documentation&lt;/a&gt;，其中明确的指出XX参数不应该在不了解的情况下使用。这是真的，并且我认为这个建议同样适用于X参数（同样一些标准参数也是）。不管类别是什么，在使用参数之前应该先了解它可能产生的影响。&lt;/p&gt;
&lt;p&gt;用一句话来说明XX参数的语法。所有的XX参数都以”-XX:”开始，但是随后的语法不同，取决于参数的类型。&lt;/p&gt;
&lt;p&gt;对于布尔类型的参数，我们有”+”或”-“，然后才设置JVM选项的实际名称。例如，-XX:+&lt;name&gt;用于激活&lt;name&gt;选项，而-XX:-&lt;name&gt;用于注销选项。&lt;br&gt;对于需要非布尔值的参数，如string或者integer，我们先写参数的名称，后面加上”=”，最后赋值。例如，  -XX:&lt;name&gt;=&lt;value&gt;给&lt;name&gt;赋值&lt;value&gt;。&lt;br&gt;现在让我们来看看JIT编译方面的一些XX参数。&lt;/value&gt;&lt;/name&gt;&lt;/value&gt;&lt;/name&gt;&lt;/name&gt;&lt;/name&gt;&lt;/name&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-XX:+PrintCompilation and -XX:+CITime&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM实用参数（三）打印所有XX参数及值</title>
    <link href="https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-3-printing-all-xx-flags-and-their-values/"/>
    <id>https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-3-printing-all-xx-flags-and-their-values/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2016-12-08T10:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自并发编程网 – ifeve.com本文链接地址: <a href="http://ifeve.com/useful-jvm-flags-part-3-printing-all-xx-flags-and-their-values/" target="_blank" rel="external">JVM实用参数（三）打印所有XX参数及值</a><br>本文是<a href="http://ifeve.com" target="_blank" rel="external">并发编程网</a>经原国外blog作者授权的中文译文</p>
</blockquote>
<p>原文地址:<a href="https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-3-printing-all-xx-flags-and-their-values/" target="_blank" rel="external">blog.codecentric.de</a></p>
<p><strong>译者：</strong>李洪柱，iDestiny<br><strong>校对：</strong>方腾飞</p>
<p>本篇文章基于Java 6（update 21oder 21之后）版本， HotSpot JVM 提供给了两个新的参数，在JVM启动后，在命令行中可以输出所有XX参数和值。</p>
<a id="more"></a>
<pre><code class="lang-bash">-XX:+PrintFlagsFinal and -XX:+PrintFlagsInitial
</code></pre>
<p>让我们现在就了解一下新参数的输出。以 -client 作为参数的 -XX:+PrintFlagsFinal   的结果是一个按字母排序的590个参数表格（注意，每个release版本参数的数量会不一样）</p>
<pre><code class="lang-bash">$ java -client -XX:+PrintFlagsFinal
[Global flags]
    uintx AdaptivePermSizeWeight                    = 20              {product}           
    uintx AdaptiveSizeDecrementScaleFactor          = 4               {product}           
    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10              {product}           
    uintx AdaptiveSizePausePolicy                   = 0               {product}           
    uintx AdaptiveSizePolicyCollectionCostMargin    = 50              {product}           
     ...
</code></pre>
<p>(校对注：你可以尝试在命令行输入上面的命令，亲自实现下)</p>
<p>表格的每一行包括五列，来表示一个XX参数。第一列表示参数的数据类型，第二列是名称，第四列为值，第五列是参数的类别。第三列”=”表示第四列是参数的默认值，而”:=” 表明了参数被用户或者JVM赋值了。</p>
<p>注意对于这个例子我只是用了Benchmark类，因为这个系列前面的章节也是用的这个类。甚至没有一个主类的情况下你能得到相同的输出，通过运行java 带另外的参数 -version.现在让我们检查下 server VM提供了多少个参数。我们也能指定参数-XX:+UnlockExperimentalVMOptions 和-XX:+UnlockDiagnosticVMOptions ；来解锁任何额外的隐藏参数。</p>
<pre><code class="lang-bash">$ java -server -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal
</code></pre>
<p>724个参数，让我们看一眼那些已经被赋值的参数</p>
<pre><code class="lang-bash">$ java -server -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal Benchmark | grep &quot;:&quot;
uintx InitialHeapSize                     := 57505088         {product}
uintx MaxHeapSize                         := 920649728        {product}
uintx ParallelGCThreads                   := 4                {product}
 bool PrintFlagsFinal                     := true             {product}
 bool UseParallelGC                       := true             {product}
</code></pre>
<p>校对注：这个命令非常有用）我们仅设置一个自己的参数 -XX:+PrintFlagsFinal。其他参数通过server VM基于系统设置的，以便以合适的堆大小和GC设置运行。</p>
<p>如果我们只想看下所有XX参数的默认值，能够用一个相关的参数，-XX:+PrintFlagsInitial  。 用 -XX:+PrintFlagsInitial, 只是展示了第三列为“=”的数据（也包括那些被设置其他值的参数）。</p>
<p>然而，注意当与-XX:+PrintFlagsFinal 对比的时候，一些参数会丢失，大概因为这些参数是动态创建的。</p>
<p>研究表格的内容是很有意思的，通过比较client和server VM的行为，很明显了解哪些参数会影响其他的参数。有兴趣的读者，可以看一下这篇不错文章<a href="http://q-redux.blogspot.com/2011/01/inspecting-hotspot-jvm-options.html" target="_blank" rel="external">Inspecting HotSpot JVM Options</a>。这个文章主要解释了第五列的参数类别。</p>
<p>-XX:+PrintCommandLineFlags<br>让我们看下另外一个参数，事实上这个参数非常有用: -XX:+PrintCommandLineFlags。这个参数让JVM打印出那些已经被用户或者JVM设置过的详细的XX参数的名称和值。</p>
<p>换句话说，它列举出 -XX:+PrintFlagsFinal的结果中第三列有”:=”的参数。以这种方式，我们可以用-XX:+PrintCommandLineFlags作为快捷方式来查看修改过的参数。看下面的例子。</p>
<pre><code class="lang-bash">$ java -server -XX:+PrintCommandLineFlags Benchmark

-XX:InitialHeapSize=57505088 -XX:MaxHeapSize=920081408 -XX:ParallelGCThreads=4 -XX:+PrintCommandLineFlags -XX:+UseParallelGC
</code></pre>
<p>现在如果我们每次启动java 程序的时候设置 -XX:+PrintCommandLineFlags 并且输出到日志文件上，这样会记录下我们设置的JVM 参数对应用程序性能的影响。类似于 -showversion(见 Part1)，我建议 –XX:+PrintCommandLineFlags 这个参数应该总是设置在JVM启动的配置项里。因为你从不知道你什么时候会需要这些信息。</p>
<p>奇怪的是在这个例子中，通过 -XX:+PrintCommandLineFlags 列出堆的最大值会比通过-XX:+PrintFlagsFinal列举出的相应值小一点。如果谁知道两者之间不同的原因，请告诉我。</p>
<blockquote>
<p>文中提到的问题，网友在原文中给的答案，仅供参考<br><a href="http://www.pixelstech.net/article/1403006488-MaxHeapSize-in-JVM" target="_blank" rel="external">http://www.pixelstech.net/article/1403006488-MaxHeapSize-in-JVM</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自并发编程网 – ifeve.com本文链接地址: &lt;a href=&quot;http://ifeve.com/useful-jvm-flags-part-3-printing-all-xx-flags-and-their-values/&quot;&gt;JVM实用参数（三）打印所有XX参数及值&lt;/a&gt;&lt;br&gt;本文是&lt;a href=&quot;http://ifeve.com&quot;&gt;并发编程网&lt;/a&gt;经原国外blog作者授权的中文译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-3-printing-all-xx-flags-and-their-values/&quot;&gt;blog.codecentric.de&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者：&lt;/strong&gt;李洪柱，iDestiny&lt;br&gt;&lt;strong&gt;校对：&lt;/strong&gt;方腾飞&lt;/p&gt;
&lt;p&gt;本篇文章基于Java 6（update 21oder 21之后）版本， HotSpot JVM 提供给了两个新的参数，在JVM启动后，在命令行中可以输出所有XX参数和值。&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM实用参数（四）内存调优</title>
    <link href="https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-4-heap-tuning/"/>
    <id>https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-4-heap-tuning/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2016-12-08T10:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自并发编程网 – ifeve.com本文链接地址: <a href="http://ifeve.com/useful-jvm-flags-part-4-heap-tuning/" target="_blank" rel="external">JVM实用参数（四）内存调优</a><br>本文是<a href="http://ifeve.com" target="_blank" rel="external">并发编程网</a>经原国外blog作者授权的中文译文</p>
</blockquote>
<p><strong>译者：</strong> 郑旭东<br><strong>校对：</strong> 梁海舰</p>
<p>理想的情况下，一个Java程序使用JVM的默认设置也可以运行得很好，所以一般来说，没有必要设置任何JVM参数。然而，由于一些性能问题（很不幸的是，这些问题经常出现），一些相关的JVM参数知识会是我们工作中得好伙伴。在这篇文章中，我们将介绍一些关于JVM内存管理的参数。知道并理解这些参数，将对开发者和运维人员很有帮助。</p>
<a id="more"></a>
<p>所有已制定的HotSpot内存管理和垃圾回收算法都基于一个相同的堆内存划分：新生代（young generation）里存储着新分配的和较年轻的对象，老年代（old generation）里存储着长寿的对象。在此之外，永久代（permanent generation）存储着那些需要伴随整个JVM生命周期的对象，比如，已加载的对象的类定义或者String对象内部Cache。接下来，我们将假设堆内存是按照新生代、老年代和永久代这一经典策略划分的。然而，其他的一些堆内存划分策略也是可行的，一个突出的例子就是新的G1垃圾回收器，它模糊了新生代和老年代之间的区别。此外，目前的开发进程似乎表明在未来的HotSpot JVM版本中，将不会区分老年代和永久代。</p>
<p><strong>-Xms and -Xmx (or: -XX:InitialHeapSize and -XX:MaxHeapSize)</strong></p>
<p>-Xms和-Xmx可以说是最流行的JVM参数，它们可以允许我们指定JVM的初始和最大堆内存大小。一般来说，这两个参数的数值单位是Byte，但同时它们也支持使用速记符号，比如“k”或者“K”代表“kilo”，“m”或者“M”代表“mega”，“g”或者“G”代表“giga”。举个例子，下面的命令启动了一个初始化堆内存为128M，最大堆内存为2G，名叫“MyApp”的Java应用程序。</p>
<pre><code class="lang-bash">$ java -Xms128m -Xmx2g MyApp
</code></pre>
<p>在实际使用过程中，初始化堆内存的大小通常被视为堆内存大小的下界。然而JVM可以在运行时动态的调整堆内存的大小，所以理论上来说我们有可能会看到堆内存的大小小于初始化堆内存的大小。但是即使在非常低的堆内存使用下，我也从来没有遇到过这种情况。这种行为将会方便开发者和系统管理员，因为我们可以通过将“-Xms”和“-Xmx”设置为相同大小来获得一个固定大小的堆内存。 -Xms和-Xmx实际上是-XX:InitialHeapSize和-XX:MaxHeapSize的缩写。我们也可以直接使用这两个参数，它们所起得效果是一样的：</p>
<pre><code class="lang-bash">$ java -XX:InitialHeapSize=128m -XX:MaxHeapSize=2g MyApp
</code></pre>
<p>需要注意的是，所有JVM关于初始\最大堆内存大小的输出都是使用它们的完整名称：“InitialHeapSize”和“InitialHeapSize”。所以当你查询一个正在运行的JVM的堆内存大小时，如使用-XX:+PrintCommandLineFlags参数或者通过JMX查询，你应该寻找“InitialHeapSize”和“InitialHeapSize”标志而不是“Xms”和“Xmx”。</p>
<p><strong>-XX:+HeapDumpOnOutOfMemoryError and -XX:HeapDumpPath</strong></p>
<p>如果我们没法为-Xmx（最大堆内存）设置一个合适的大小，那么就有可能面临内存溢出（OutOfMemoryError）的风险，这可能是我们使用JVM时面临的最可怕的猛兽之一。就同<a href="http://blog.codecentric.de/en/2011/03/java-memory-configuration-and-monitoring-3rd-act/" target="_blank" rel="external">另外一篇</a>关于这个主题的博文说的一样，导致内存溢出的根本原因需要仔细的定位。通常来说，分析堆内存快照（Heap Dump）是一个很好的定位手段，如果发生内存溢出时没有生成内存快照那就实在是太糟了，特别是对于那种JVM已经崩溃或者错误只出现在顺利运行了数小时甚至数天的生产系统上的情况。</p>
<p>幸运的是，我们可以通过设置-XX:+HeapDumpOnOutOfMemoryError 让JVM在发生内存溢出时自动的生成堆内存快照。有了这个参数，当我们不得不面对内存溢出异常的时候会节约大量的时间。默认情况下，堆内存快照会保存在JVM的启动目录下名为java_pid<code>&lt;pid&gt;</code>.hprof 的文件里（在这里<code>&lt;pid&gt;</code>就是JVM进程的进程号）。也可以通过设置-XX:HeapDumpPath=<code>&lt;path&gt;</code>来改变默认的堆内存快照生成路径，<code>&lt;path&gt;</code>可以是相对或者绝对路径。</p>
<p>虽然这一切听起来很不错，但有一点我们需要牢记。堆内存快照文件有可能很庞大，特别是当内存溢出错误发生的时候。因此，我们推荐将堆内存快照生成路径指定到一个拥有足够磁盘空间的地方。</p>
<p><strong>-XX:OnOutOfMemoryError</strong></p>
<p>当内存溢发生时，我们甚至可以可以执行一些指令，比如发个E-mail通知管理员或者执行一些清理工作。通过-XX:OnOutOfMemoryError 这个参数我们可以做到这一点，这个参数可以接受一串指令和它们的参数。在这里，我们将不会深入它的细节，但我们提供了它的一个例子。在下面的例子中，当内存溢出错误发生的时候，我们会将堆内存快照写到/tmp/heapdump.hprof 文件并且在JVM的运行目录执行脚本cleanup.sh</p>
<pre><code class="lang-bash">$ java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof -XX:OnOutOfMemoryError =&quot;sh ~/cleanup.sh&quot; MyApp
</code></pre>
<p><strong>-XX:PermSize and -XX:MaxPermSize</strong><br>永久代在堆内存中是一块独立的区域，它包含了所有JVM加载的类的对象表示。为了成功运行应用程序，JVM会加载很多类（因为它们依赖于大量的第三方库，而这又依赖于更多的库并且需要从里面将类加载进来）这就需要增加永久代的大小。我们可以使用-XX:PermSize 和-XX:MaxPermSize 来达到这个目的。其中-XX:MaxPermSize 用于设置永久代大小的最大值，-XX:PermSize 用于设置永久代初始大小。下面是一个简单的例子：</p>
<pre><code class="lang-bash">$ java -XX:PermSize=128m -XX:MaxPermSize=256m MyApp
</code></pre>
<p>请注意，这里设置的永久代大小并不会被包括在使用参数-XX:MaxHeapSize 设置的堆内存大小中。也就是说，通过-XX:MaxPermSize设置的永久代内存可能会需要由参数-XX:MaxHeapSize 设置的堆内存以外的更多的一些堆内存。</p>
<p><strong>-XX:InitialCodeCacheSize and -XX:ReservedCodeCacheSize</strong></p>
<p>JVM一个有趣的，但往往被忽视的内存区域是“代码缓存”，它是用来存储已编译方法生成的本地代码。代码缓存确实很少引起性能问题，但是一旦发生其影响可能是毁灭性的。如果代码缓存被占满，JVM会打印出一条警告消息，并切换到interpreted-only 模式：JIT编译器被停用，字节码将不再会被编译成机器码。因此，应用程序将继续运行，但运行速度会降低一个数量级，直到有人注意到这个问题。就像其他内存区域一样，我们可以自定义代码缓存的大小。相关的参数是-XX:InitialCodeCacheSize 和-XX:ReservedCodeCacheSize，它们的参数和上面介绍的参数一样，都是字节值。</p>
<p><strong>-XX:+UseCodeCacheFlushing</strong></p>
<p>如果代码缓存不断增长，例如，因为热部署引起的内存泄漏，那么提高代码的缓存大小只会延缓其发生溢出。为了避免这种情况的发生，我们可以尝试一个有趣的新参数：当代码缓存被填满时让JVM放弃一些编译代码。通过使用-XX:+UseCodeCacheFlushing 这个参数，我们至少可以避免当代码缓存被填满的时候JVM切换到interpreted-only 模式。不过，我仍建议尽快解决代码缓存问题发生的根本原因，如找出内存泄漏并修复它。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自并发编程网 – ifeve.com本文链接地址: &lt;a href=&quot;http://ifeve.com/useful-jvm-flags-part-4-heap-tuning/&quot;&gt;JVM实用参数（四）内存调优&lt;/a&gt;&lt;br&gt;本文是&lt;a href=&quot;http://ifeve.com&quot;&gt;并发编程网&lt;/a&gt;经原国外blog作者授权的中文译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;译者：&lt;/strong&gt; 郑旭东&lt;br&gt;&lt;strong&gt;校对：&lt;/strong&gt; 梁海舰&lt;/p&gt;
&lt;p&gt;理想的情况下，一个Java程序使用JVM的默认设置也可以运行得很好，所以一般来说，没有必要设置任何JVM参数。然而，由于一些性能问题（很不幸的是，这些问题经常出现），一些相关的JVM参数知识会是我们工作中得好伙伴。在这篇文章中，我们将介绍一些关于JVM内存管理的参数。知道并理解这些参数，将对开发者和运维人员很有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM实用参数（五）新生代垃圾回收</title>
    <link href="https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-5-young-generation-garbage-collection/"/>
    <id>https://www.deleiguo.com/2016/10/08/useful-jvm-flags-part-5-young-generation-garbage-collection/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2016-12-08T10:21:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自并发编程网 – ifeve.com本文链接地址: <a href="http://ifeve.com/useful-jvm-flags-part-5-young-generation-garbage-collection/" target="_blank" rel="external">JVM实用参数（五）新生代垃圾回收</a><br>本文是<a href="http://ifeve.com" target="_blank" rel="external">并发编程网</a>经原国外blog作者授权的中文译文</p>
</blockquote>
<p><strong>译者：</strong> 严亮<br>本部分，我们将关注堆(heap) 中一个主要区域，新生代(young generation)。首先我们会讨论为什么调整新生代的参数会对应用的性能如此重要，接着我们将学习新生代相关的JVM参数。</p>
<p>单纯从JVM的功能考虑，并不需要新生代，完全可以针对整个堆进行操作。新生代存在的唯一理由是优化垃圾回收(GC)的性能。更具体说，把堆划分为新生代和老年代有2个好处：简化了新对象的分配(只在新生代分配内存),可以更有效的清除不再需要的对象(即死对象)(新生代和老年代使用不同的GC算法)</p>
<p>通过广泛研究面向对象实现的应用，发现一个共同特点：很多对象的生存时间都很短。同时研究发现，新生对象很少引用生存时间长的对象。结合这2个特点，很明显 GC 会频繁访问新生对象，例如在堆中一个单独的区域，称之为新生代。在新生代中，GC可以快速标记回收”死对象”，而不需要扫描整个Heap中的存活一段时间的”老对象”。</p>
<a id="more"></a>
<p>SUN/Oracle 的HotSpot JVM 又把新生代进一步划分为3个区域：一个相对大点的区域，称为”伊甸园区(Eden)”；两个相对小点的区域称为”From 幸存区(survivor)”和”To 幸存区(survivor)”。按照规定,新对象会首先分配在 Eden 中(如果新对象过大，会直接分配在老年代中)。在GC中，Eden 中的对象会被移动到survivor中，直至对象满足一定的年纪(定义为熬过GC的次数),会被移动到老年代。</p>
<p>基于大多数新生对象都会在GC中被收回的假设。新生代的GC 使用复制算法。在GC前To 幸存区(survivor)保持清空,对象保存在 Eden 和 From 幸存区(survivor)中，GC运行时,Eden中的幸存对象被复制到 To 幸存区(survivor)。针对 From 幸存区(survivor)中的幸存对象，会考虑对象年龄,如果年龄没达到阀值(tenuring threshold)，对象会被复制到To 幸存区(survivor)。如果达到阀值对象被复制到老年代。复制阶段完成后，Eden 和From 幸存区中只保存死对象，可以视为清空。如果在复制过程中To 幸存区被填满了，剩余的对象会被复制到老年代中。最后 From 幸存区和 To幸存区会调换下名字，在下次GC时，To 幸存区会成为From 幸存区。</p>
<p><img src="http://www.deleiguo.com/wordpress/wp-content/uploads/2016/10/young_gc.png" alt=""></p>
<p><a href="https://blog.codecentric.de/files/2011/08/young_gc.png" target="_blank" rel="external">https://blog.codecentric.de/files/2011/08/young_gc.png</a><br>上图演示GC过程，黄色表示死对象，绿色表示剩余空间，红色表示幸存对象</p>
<p>总结一下，对象一般出生在Eden区，年轻代GC过程中，对象在2个幸存区之间移动，如果对象存活到适当的年龄，会被移动到老年代。当对象在老年代死亡时，就需要更高级别的GC，更重量级的GC算法(复制算法不适用于老年代，因为没有多余的空间用于复制)</p>
<p>现在应该能理解为什么新生代大小非常重要了(译者,有另外一种说法：新生代大小并不重要，影响GC的因素主要是幸存对象的数量)，如果新生代过小，会导致新生对象很快就晋升到老年代中，在老年代中对象很难被回收。如果新生代过大，会发生过多的复制过程。我们需要找到一个合适大小，不幸的是，要想获得一个合适的大小，只能通过不断的测试调优。这就需要JVM参数了</p>
<h2 id="XX-NewSize-and-XX-MaxNewSize"><a href="#XX-NewSize-and-XX-MaxNewSize" class="headerlink" title="-XX:NewSize and -XX:MaxNewSize"></a>-XX:NewSize and -XX:MaxNewSize</h2><p>就像可以通过参数(-Xms and -Xmx) 指定堆大小一样，可以通过参数指定新生代大小。设置 XX:MaxNewSize 参数时，应该考虑到新生代只是整个堆的一部分，新生代设置的越大，老年代区域就会减少。一般不允许新生代比老年代还大，因为要考虑GC时最坏情况，所有对象都晋升到老年代。(译者:会发生OOM错误) -XX:MaxNewSize 最大可以设置为-Xmx/2 .</p>
<p>考虑性能，一般会通过参数 -XX:NewSize 设置新生代初始大小。如果知道新生代初始分配的对象大小(经过监控) ，这样设置会有帮助，可以节省新生代自动扩展的消耗。</p>
<h2 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h2><p>可以设置新生代和老年代的相对大小。这种方式的优点是新生代大小会随着整个堆大小动态扩展。参数 -XX:NewRatio 设置老年代与新生代的比例。例如 -XX:NewRatio=3 指定老年代/新生代为3/1. 老年代占堆大小的 3/4 ，新生代占 1/4 .</p>
<p>如果针对新生代,同时定义绝对值和相对值,绝对值将起作用。下面例子：</p>
<pre><code class="lang-bash">$ java -XX:NewSize=32m -XX:MaxNewSize=512m -XX:NewRatio=3 MyApp
</code></pre>
<p>以上设置, JVM 会尝试为新生代分配四分之一的堆大小，但不会小于32MB或大于521MB</p>
<p>在设置新生代大小问题上，使用绝对值还是相对值，不存在通用准则 。如果了解应用的内存使用情况,设置固定大小的堆和新生代更有利，当然也可以设置相对值。如果对应用的内存使用一无所知,正确的做法是不要设置任何参数，如果应用运行良好。很好，我们不用做任何额外动作.如果遇到性能或OutOfMemoryErrors, 在调优之前，首先需要进行一系列有目的的监控测试，缩小问题的根源。</p>
<h2 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h2><p>参数 -XX:SurvivorRatio 与 -XX:NewRatio 类似，作用于新生代内部区域。-XX:SurvivorRatio 指定伊甸园区(Eden)与幸存区大小比例. 例如, -XX:SurvivorRatio=10 表示伊甸园区(Eden)是 幸存区To 大小的10倍(也是幸存区From的10倍).所以,伊甸园区(Eden)占新生代大小的10/12, 幸存区From和幸存区To 每个占新生代的1/12 .注意,两个幸存区永远是一样大的..</p>
<p>设定幸存区大小有什么作用? 假设幸存区相对伊甸园区(Eden)太小, 相应新生对象的伊甸园区(Eden)永远很大空间, 我们当然希望,如果这些对象在GC时全部被回收,伊甸园区(Eden)被清空,一切正常.然而,如果有一部分对象在GC中幸存下来, 幸存区只有很少空间容纳这些对象.结果大部分幸存对象在一次GC后，就会被转移到老年代 ,这并不是我们希望的.考虑相反情况, 假设幸存区相对伊甸园区(Eden)太大,当然有足够的空间，容纳GC后的幸存对象. 但是过小的伊甸园区(Eden),意味着空间将越快耗尽，增加新生代GC次数，这是不可接受的。</p>
<p>总之,我们希望最小化短命对象晋升到老年代的数量，同时也希望最小化新生代GC 的次数和持续时间.我们需要找到针对当前应用的折中方案, 寻找适合方案的起点是 了解当前应用中对象的年龄分布情况。</p>
<h2 id="XX-PrintTenuringDistribution"><a href="#XX-PrintTenuringDistribution" class="headerlink" title="-XX:+PrintTenuringDistribution"></a>-XX:+PrintTenuringDistribution</h2><p>参数 -XX:+PrintTenuringDistribution 指定JVM 在每次新生代GC时，输出幸存区中对象的年龄分布。例如:</p>
<pre><code class="lang-bash">Desired survivor size 75497472 bytes, new threshold 15 (max 15)
- age 1: 19321624 bytes, 19321624 total
- age 2: 79376 bytes, 19401000 total
- age 3: 2904256 bytes, 22305256 total
</code></pre>
<p>第一行说明幸存区To大小为 75 MB. 也有关于老年代阀值(tenuring threshold)的信息, 老年代阀值，意思是对象从新生代移动到老年代之前，经过几次GC(即, 对象晋升前的最大年龄). 上例中,老年代阀值为15,最大也是15.</p>
<p>之后行表示，对于小于老年代阀值的每一个对象年龄,本年龄中对象所占字节 (如果当前年龄没有对象,这一行会忽略). 上例中,一次 GC 后幸存对象大约 19 MB, 两次GC 后幸存对象大约79 KB , 三次GC 后幸存对象大约 3 MB .每行结尾，显示直到本年龄全部对象大小.所以,最后一行的 total 表示幸存区To 总共被占用22 MB . 幸存区To 总大小为 75 MB ,当前老年代阀值为15，可以断定在本次GC中，没有对象会移动到老年代。现在假设下一次GC 输出为：</p>
<pre><code class="lang-bash">Desired survivor size 75497472 bytes, new threshold 2 (max 15)
- age 1: 68407384 bytes, 68407384 total
- age 2: 12494576 bytes, 80901960 total
- age 3: 79376 bytes, 80981336 total
- age 4: 2904256 bytes, 83885592 total
</code></pre>
<p>对比前一次老年代分布。明显的,年龄2和年龄3 的对象还保持在幸存区中，因为我们看到年龄3和4的对象大小与前一次年龄2和3的相同。同时发现幸存区中,有一部分对象已经被回收,因为本次年龄2的对象大小为 12MB ，而前一次年龄1的对象大小为 19 MB。最后可以看到最近的GC中，有68 MB 新对象，从伊甸园区移动到幸存区。</p>
<p>注意,本次GC 幸存区占用总大小 84 MB -大于75 MB. 结果,JVM 把老年代阀值从15降低到2，在下次GC时，一部分对象会强制离开幸存区，这些对象可能会被回收(如果他们刚好死亡)或移动到老年代。</p>
<h2 id="XX-InitialTenuringThreshold-XX-MaxTenuringThreshold-and-XX-TargetSurvivorRatio"><a href="#XX-InitialTenuringThreshold-XX-MaxTenuringThreshold-and-XX-TargetSurvivorRatio" class="headerlink" title="-XX:InitialTenuringThreshold, -XX:MaxTenuringThreshold and -XX:TargetSurvivorRatio"></a>-XX:InitialTenuringThreshold, -XX:MaxTenuringThreshold and -XX:TargetSurvivorRatio</h2><p>参数 -XX:+PrintTenuringDistribution 输出中的部分值可以通过其它参数控制。通过 -XX:InitialTenuringThreshold 和 -XX:MaxTenuringThreshold 可以设定老年代阀值的初始值和最大值。另外,可以通过参数 -XX:TargetSurvivorRatio 设定幸存区的目标使用率.例如 , -XX:MaxTenuringThreshold=10 -XX:TargetSurvivorRatio=90 设定老年代阀值的上限为10,幸存区空间目标使用率为90%。</p>
<p>有多种方式,设置新生代行为，没有通用准则。我们必须清楚以下2中情况：<br>1 如果从年龄分布中发现，有很多对象的年龄持续增长，在到达老年代阀值之前。这表示 -XX:MaxTenuringThreshold 设置过大<br>2 如果 -XX:MaxTenuringThreshold 的值大于1，但是很多对象年龄从未大于1.应该看下幸存区的目标使用率。如果幸存区使用率从未到达，这表示对象都被GC回收，这正是我们想要的。 如果幸存区使用率经常达到，有些年龄超过1的对象被移动到老年代中。这种情况，可以尝试调整幸存区大小或目标使用率。</p>
<h2 id="XX-NeverTenure-and-XX-AlwaysTenure"><a href="#XX-NeverTenure-and-XX-AlwaysTenure" class="headerlink" title="-XX:+NeverTenure and -XX:+AlwaysTenure"></a>-XX:+NeverTenure and -XX:+AlwaysTenure</h2><p>最后,我们介绍2个颇为少见的参数,对应2种极端的新生代GC情况.设置参数 -XX:+NeverTenure , 对象永远不会晋升到老年代.当我们确定不需要老年代时，可以这样设置。这样设置风险很大,并且会浪费至少一半的堆内存。相反设置参数 -XX:+AlwaysTenure, 表示没有幸存区,所有对象在第一次GC时，会晋升到老年代。<br>没有合理的场景使用这个参数。可以在测试环境中，看下这样设置会发生什么有趣的事.但是并不推荐使用这些参数.</p>
<p>结论<br>适当的配置新生代非常重要，有相当多的参数可以设置新生代。然而，单独调整新生代，而不考虑老年代是不可能优化成功的。当调整堆和GC设置时，我们总是应该同时考虑新生代和老年代。</p>
<p>在本系列的下面2部分，我们将讨论 HotSpot JVM 中老年代 GC 策略,我们会学习“吞吐量GC收集器” 和 “并发低延迟GC收集器”,也会了解收集器的基本准则，算法和调整参数.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自并发编程网 – ifeve.com本文链接地址: &lt;a href=&quot;http://ifeve.com/useful-jvm-flags-part-5-young-generation-garbage-collection/&quot;&gt;JVM实用参数（五）新生代垃圾回收&lt;/a&gt;&lt;br&gt;本文是&lt;a href=&quot;http://ifeve.com&quot;&gt;并发编程网&lt;/a&gt;经原国外blog作者授权的中文译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;译者：&lt;/strong&gt; 严亮&lt;br&gt;本部分，我们将关注堆(heap) 中一个主要区域，新生代(young generation)。首先我们会讨论为什么调整新生代的参数会对应用的性能如此重要，接着我们将学习新生代相关的JVM参数。&lt;/p&gt;
&lt;p&gt;单纯从JVM的功能考虑，并不需要新生代，完全可以针对整个堆进行操作。新生代存在的唯一理由是优化垃圾回收(GC)的性能。更具体说，把堆划分为新生代和老年代有2个好处：简化了新对象的分配(只在新生代分配内存),可以更有效的清除不再需要的对象(即死对象)(新生代和老年代使用不同的GC算法)&lt;/p&gt;
&lt;p&gt;通过广泛研究面向对象实现的应用，发现一个共同特点：很多对象的生存时间都很短。同时研究发现，新生对象很少引用生存时间长的对象。结合这2个特点，很明显 GC 会频繁访问新生对象，例如在堆中一个单独的区域，称之为新生代。在新生代中，GC可以快速标记回收”死对象”，而不需要扫描整个Heap中的存活一段时间的”老对象”。&lt;/p&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux 跟踪域名解析过程</title>
    <link href="https://www.deleiguo.com/2016/10/08/linux-follow-dns/"/>
    <id>https://www.deleiguo.com/2016/10/08/linux-follow-dns/</id>
    <published>2016-10-08T11:19:56.000Z</published>
    <updated>2016-12-08T10:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令一-nslookup"><a href="#命令一-nslookup" class="headerlink" title="命令一:nslookup"></a>命令一:nslookup</h2><blockquote>
<p>linux and windows</p>
</blockquote>
<pre><code>delei@XXX:~$ nslookup
&gt; www.deleiguo.com
Server:        192.168.1.1
Address:    192.168.1.1#53

Non-authoritative answer:
www.deleiguo.com    canonical name = ew-2l6hqh9le.aliapp.com.
Name:    ew-2l6hqh9le.aliapp.com
Address: 121.199.250.133
</code></pre><h2 id="命令二-dig"><a href="#命令二-dig" class="headerlink" title="命令二:dig"></a>命令二:dig</h2><blockquote>
<p>linux</p>
</blockquote>
<pre><code>delei@XXX:~$ dig www.deleiguo.com

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.deleiguo.com
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 13977
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;www.deleiguo.com.        IN    A

;; ANSWER SECTION:
www.deleiguo.com.    222    IN    CNAME    ew-2l6hqh9le.aliapp.com.
ew-2l6hqh9le.aliapp.com. 222    IN    A    121.199.250.133

;; Query time: 39 msec
;; SERVER: 192.168.1.1#53(192.168.1.1)
;; WHEN: Sat Oct  8 19:15:18 2016
;; MSG SIZE  rcvd: 87
</code></pre><p>增加+trace参数跟踪过程：</p>
<pre><code>delei@XXX:~$ dig www.deleiguo.com +trace

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.deleiguo.com +trace
;; global options: +cmd
.            89065    IN    NS    c.root-servers.net.
.            89065    IN    NS    j.root-servers.net.
.            89065    IN    NS    g.root-servers.net.
.            89065    IN    NS    d.root-servers.net.
.            89065    IN    NS    h.root-servers.net.
.            89065    IN    NS    f.root-servers.net.
.            89065    IN    NS    b.root-servers.net.
.            89065    IN    NS    l.root-servers.net.
.            89065    IN    NS    k.root-servers.net.
.            89065    IN    NS    a.root-servers.net.
.            89065    IN    NS    e.root-servers.net.
.            89065    IN    NS    m.root-servers.net.
.            89065    IN    NS    i.root-servers.net.
;; Received 228 bytes from 223.5.5.5#53(223.5.5.5) in 44 ms

com.            172800    IN    NS    j.gtld-servers.net.
com.            172800    IN    NS    i.gtld-servers.net.
com.            172800    IN    NS    c.gtld-servers.net.
com.            172800    IN    NS    l.gtld-servers.net.
com.            172800    IN    NS    g.gtld-servers.net.
com.            172800    IN    NS    h.gtld-servers.net.
com.            172800    IN    NS    m.gtld-servers.net.
com.            172800    IN    NS    d.gtld-servers.net.
com.            172800    IN    NS    a.gtld-servers.net.
com.            172800    IN    NS    b.gtld-servers.net.
com.            172800    IN    NS    e.gtld-servers.net.
com.            172800    IN    NS    k.gtld-servers.net.
com.            172800    IN    NS    f.gtld-servers.net.
;; Received 494 bytes from 192.5.5.241#53(192.5.5.241) in 62 ms

deleiguo.com.        172800    IN    NS    dns9.hichina.com.
deleiguo.com.        172800    IN    NS    dns10.hichina.com.
;; Received 177 bytes from 192.35.51.30#53(192.35.51.30) in 198 ms

www.deleiguo.com.    600    IN    CNAME    ew-2l6hqh9le.aliapp.com.
;; Received 71 bytes from 140.205.81.13#53(140.205.81.13) in 7 ms
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命令一-nslookup&quot;&gt;&lt;a href=&quot;#命令一-nslookup&quot; class=&quot;headerlink&quot; title=&quot;命令一:nslookup&quot;&gt;&lt;/a&gt;命令一:nslookup&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;linux and windows
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="Linux" scheme="https://www.deleiguo.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JVM类型与模式[JAVA -VERSION]</title>
    <link href="https://www.deleiguo.com/2016/08/17/jvm-type-and-mode/"/>
    <id>https://www.deleiguo.com/2016/08/17/jvm-type-and-mode/</id>
    <published>2016-08-17T08:01:10.000Z</published>
    <updated>2016-12-08T10:19:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>基本上一开始学习Java，就接触到第一个Java的命令:<code>java -version</code><br>这个命令最常用的就是用来查看当前服务器的JDK环境版本，以此验证服务器环境变量是否已正确的设置好JDK。<br>最常见的结果一般有两种：</p>
<ul>
<li><p><strong>Sun JDK</strong>:</p>
<pre><code>delei@DeleitekiMBP:~$ java -version
java version &quot;1.7.0_79&quot;
Java(TM) SE Runtime Environment (build 1.7.0_79-b15)
Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)
</code></pre></li>
<li><p><strong>Open JDK</strong>:</p>
<pre><code>root@ubuntu-server:~# java -version
java version &quot;1.7.0_95&quot;
OpenJDK Runtime Environment (IcedTea 2.6.4) (7u95-2.6.4-0ubuntu0.15.10.1)
OpenJDK 64-Bit Server VM (build 24.95-b01, mixed mode)
</code></pre></li>
</ul>
<a id="more"></a>
<blockquote>
<p>第一行:JDK的版本号<br>第二行：JDK的运行环境</p>
</blockquote>
<p>但第三行是指的什么，在一开始没留意也不理解这一行包含着哪些信息，这里以Sun JDK为例来稍微深入看一下.</p>
<pre><code>  Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)
</code></pre><ul>
<li><p>Java HotSpot(TM)</p>
<ul>
<li>这是从Sun公司开始，到Oracle后一直使用的虚拟机;</li>
<li>其实JVM只是一个规范，可以自己实现虚拟机；</li>
<li>目前市面上常用的商业虚拟机有：HotSpot(Oracle 和 openjdk),IBM的J9 vm，Azul Systems 的Zing等 <a href="http://www.zhihu.com/question/29265430?sort=created" target="_blank" rel="external">zhihu</a>;</li>
<li>其他虚拟机：<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines" target="_blank" rel="external">wikipedia</a></li>
</ul>
</li>
<li><p>64-Bit</p>
<ul>
<li>如果安装的是64位的则是64-bit,如果安装是32位，则为32-bit。</li>
<li>这里不是服务器的操作系统，而是指的当前安装JDK</li>
</ul>
</li>
<li><p>Server VM</p>
<ul>
<li>Server VM</li>
<li>Client VM</li>
</ul>
</li>
<li><p>mixed mode</p>
<ul>
<li>mixed mode:混合模式</li>
<li>class data sharing：类数据共享</li>
<li>interpreted mode:解释模式</li>
</ul>
</li>
</ul>
<hr>
<h1 id="JVM类型"><a href="#JVM类型" class="headerlink" title="JVM类型"></a>JVM类型</h1><p>首先要知道的的是Server VM和Client VM可以理解是不同的虚拟机。<br>如果操作系统是64位的，只能是Server VM，Client VM只有在32位上才有。<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/server-class.html" target="_blank" rel="external">Oracle官方</a></p>
<p>Server VM和Client VM有什么区别？在官网的FAQ中有如下的描述：</p>
<p><strong>JIT Compiler</strong><br>1.<strong>What’s the difference between the -client and -server systems?</strong></p>
<pre><code class="lang-XML">These two systems are different binaries. They are essentially two different compilers (JITs)interfacing to the same runtime system. The client system is optimal for applications which need fast startup times or small footprints, the server system is optimal for applications where the overall performance is most important. In general the client system is better suited for interactive applications such as GUIs. Some of the other differences include the compilation policy,heap defaults, and inlining policy.
</code></pre>
<blockquote>
<p> 大致翻译：<br> 这两个JVM采用不同的编译器。<br> Client JVM适合快速启动和较小内存的，它适合强调交互的应用，比如GUI(桌面级应用界面)；<br> Server JVM则是偏重执行时候的效率的。<br> 其他不同的地方”编译策略”、”默认堆大小”、”内嵌策略”</p>
</blockquote>
<p>2.<strong>Where do I get the server and client systems?</strong></p>
<pre><code>Client and server systems are both downloaded with the 32-bit Solaris and Linux downloads. For 32-bit Windows, if you download the JRE, you get only the client, you&#39;ll need to download the SDK to get both systems.

For 64-bit, only the server system is included. On Solaris, the 64-bit JRE is an overlay on top of the 32-bit distribution. However, on Linux and Windows, it&#39;s a completely separate distribution.
</code></pre><blockquote>
<p> 主要内容翻译：<br> 在32位的系统中，如果下载JRE,则只有client；<br> 从Java SE 5.0开始，在64位的系统中，默认的时候Server，32位的默认</p>
</blockquote>
<p>以上是从官方得到的原理/规范使用上的一些说明。接下来看在实际当中，如何切换Server VM和Client VM：</p>
<ul>
<li>想要在windows系统中进行切换，需要下载JDK而不是JRE;</li>
<li>在Windows 系统中，找到JDK(%JAVA_HOME%)安装的目录<code>/jre/lib</code>，该目录下会有<code>server</code>和<code>client</code>两个不同的目录;</li>
</ul>
<ol>
<li><p>命令切换(推荐)<br>在CMD/终端命令中，执行<code>java -server -version</code>和<code>java -client -version</code>即可切换;</p>
</li>
<li><p>修改文件(永久切换)<br>在<code>jre/lib/i386/</code>(32位的JDK有i386文件夹)，编辑修改jvm.cfg文件</p>
</li>
</ol>
<pre><code># List of JVMs that can be used as an option to java, javac, etc.
# Order is important -- first in this list is the default JVM.
# NOTE that this both this file and its format are UNSUPPORTED and
# WILL GO AWAY in a future release.
#
# You may also select a JVM in an arbitrary location with the
# &quot;-XXaltjvm=&lt;jvm_dir&gt;&quot; option, but that too is unsupported
# and may not be available in a future release.
#
-client KNOWN
-server KNOWN
-hotspot ALIASED_TO -client
-classic WARN
-native ERROR
-green ERROR
</code></pre><p> <code># Order is important -- first in this list is the default JVM.</code><br> 第一行的配置则为默认的JVM，这里第一行是-client，所有默认是Client VM;<br> 要想用Server VM，则将第二行与第三行调换位置保存即可;</p>
<p><strong>应用场景</strong></p>
<ol>
<li>我们时常会在开发/生产环境中对web 服务器调整JVM的参数，一般来说目前服务器都是64位的，可以先用java -version来查看环境;</li>
<li>根据应用的场景需要，在jvm中加上<code>-server</code> 参数;</li>
</ol>
<hr>
<h1 id="JVM运行模式"><a href="#JVM运行模式" class="headerlink" title="JVM运行模式"></a>JVM运行模式</h1><p>在CMD/终端命令中，执行<code>java -X</code></p>
<pre><code>root@ubuntu-server:~# java -X
    -Xmixed           mixed mode execution (default)
    -Xint             interpreted mode execution only
</code></pre><p>在此可以知道mixed是默认的模式；<br>JVM模式有：-Xint, -Xcomp, 和 -Xmixed</p>
<ul>
<li><p><strong> -Xint</strong><br>在解释模式(interpreted mode)下，-Xint标记会强制JVM执行所有的字节码，当然这会降低运行速度，通常低10倍或更多。</p>
</li>
<li><p><strong> -Xcomp</strong><br>-Xcomp参数与它（-Xint）正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。这听起来不错，因为这完全绕开了缓慢的解释器</p>
</li>
<li><p><strong>-Xmixed</strong><br>混合模式(mixed mode)，是JVM的默认工作模式。它会同时使用编译模式和解释模式。对于字节码中多次被调用的部分，JVM会将其编译成本地代码以提高执行效率；而被调用很少（甚至只有一次）的方法在解释模式下会继续执行，从而减少编译和优化成本。JIT编译器在运行时创建方法使用文件，然后一步一步的优化每一个方法，有时候会主动的优化应用的行为。这些优化技术，比如积极的分支预测（optimistic branch prediction），如果不先分析应用就不能有效的使用。这样将频繁调用的部分提取出来，编译成本地代码，也就是在应用中构建某种热点（即HotSpot，这也是HotSpot JVM名字的由来）。使用混合模式可以获得最好的执行效率。</p>
</li>
</ul>
<p>在CMD/终端命令中，可以直接通过命令来切换模式：</p>
<pre><code>root@ubuntu-server:~# java -Xint -version
java version &quot;1.7.0_95&quot;
OpenJDK Runtime Environment (IcedTea 2.6.4) (7u95-2.6.4-0ubuntu0.15.10.1)
OpenJDK 64-Bit Server VM (build 24.95-b01, interpreted mode)

root@ubuntu-server:~# java -Xcomp -version
java version &quot;1.7.0_95&quot;
OpenJDK Runtime Environment (IcedTea 2.6.4) (7u95-2.6.4-0ubuntu0.15.10.1)
OpenJDK 64-Bit Server VM (build 24.95-b01, compiled mode)
</code></pre><p><strong> 代码验证</strong><br>我们通过一个小的Java代码来验证下不同mode下的执行耗时(Server VM)</p>
<pre><code class="lang-JAVA">public class JVMModeTest {

    private static void test() {//循环++
        for (int i =0;i&lt;1000000000;i++) {
        }
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        test();
        long end = System.currentTimeMillis();
        System.out.println(end-start);//打印执行耗时
    }

}
</code></pre>
<p>结果如下：</p>
<pre><code>root@ubuntu-server:~/work/java$ java -Xcomp JVMModeTest
2
root@ubuntu-server:~/work/java$ java -Xint JVMModeTest
28562
root@ubuntu-server:~/work/java$ java -Xmixed JVMModeTest
18
</code></pre><blockquote>
<p>引用原文：<a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</a></p>
</blockquote>
<p>由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行的速度也有影响。为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译（Tiered Compilation）[4]的策略，分层编译的概念在JDK 1.6时期出现，后来一直处于改进阶段，最终在JDK 1.7的Server模式虚拟机中作为默认编译策略被开启。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p>
<ul>
<li><p>第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第1层编译。</p>
</li>
<li><p>第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。</p>
</li>
<li><p>第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</p>
</li>
</ul>
<p>实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会被多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务</p>
<p>注：<br>[1] 在虚拟机中习惯将Client Compiler称为C1，将Server Compiler称为C2。</p>
<hr>
<h1 id="参考-引用"><a href="#参考-引用" class="headerlink" title="参考/引用"></a>参考/引用</h1><p><a href="http://my.oschina.net/itblog/blog/507822" target="_blank" rel="external">http://my.oschina.net/itblog/blog/507822</a><br><a href="http://ifeve.com/useful-jvm-flags-part-1-jvm-types-and-compiler-modes-2/" target="_blank" rel="external">http://ifeve.com/useful-jvm-flags-part-1-jvm-types-and-compiler-modes-2/</a><br><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</a></p>
<p><a href="http://www.oracle.com/technetwork/java/hotspotfaq-138619.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/hotspotfaq-138619.html</a><br><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/server-class.html" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/server-class.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;基本上一开始学习Java，就接触到第一个Java的命令:&lt;code&gt;java -version&lt;/code&gt;&lt;br&gt;这个命令最常用的就是用来查看当前服务器的JDK环境版本，以此验证服务器环境变量是否已正确的设置好JDK。&lt;br&gt;最常见的结果一般有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sun JDK&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delei@DeleitekiMBP:~$ java -version
java version &amp;quot;1.7.0_79&amp;quot;
Java(TM) SE Runtime Environment (build 1.7.0_79-b15)
Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Open JDK&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ubuntu-server:~# java -version
java version &amp;quot;1.7.0_95&amp;quot;
OpenJDK Runtime Environment (IcedTea 2.6.4) (7u95-2.6.4-0ubuntu0.15.10.1)
OpenJDK 64-Bit Server VM (build 24.95-b01, mixed mode)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="TEC-技术" scheme="https://www.deleiguo.com/categories/tec/"/>
    
    
      <category term="JVM" scheme="https://www.deleiguo.com/tags/JVM/"/>
    
  </entry>
  
</feed>
